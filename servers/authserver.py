import ast
import binascii
import datetime
import hashlib
import hmac
import logging
import os
import pprint
import random
import secrets
import shutil
import socket as real_socket
import struct
import time
import zlib
import ipcalc
from Crypto.Hash import SHA
from Crypto.Signature import pkcs1_15
from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA1
from Crypto.PublicKey import RSA
import globalvars
import utilities.encryption as encryption
import utilities.name_suggestor
import utils

from utilities import cdr_manipulator, sendmail, validationcode_manager
from utilities import blobs
from utilities.database import ccdb
from utilities.networkhandler import TCPNetworkHandler
from utilities.sendmail import send_password_changed_email


# noinspection ProblematicWhitespace
class authserver(TCPNetworkHandler):
	def __init__(self, port, config):
		self.server_type = "AuthServer"
		self.innerkey = binascii.a2b_hex("10231230211281239191238542314233")
		self.manager = validationcode_manager.VerificationCodeManager()
		self.suggestednames_amnt = int(config['amount_of_suggested_names'])
		# Create an instance of NetworkHandler
		super(authserver, self).__init__(config, port, self.server_type)

	def send_mainkey(self, client_socket):
		mainkey = encryption.signed_mainkey_reply
		client_socket.send(mainkey)

	def handle_client(self, client_socket, client_address):
		log = logging.getLogger(self.server_type)
		# Load this everytime a client connects, this ensures that we can change the blob without restarting the server
		globalvars.firstblob_eval = ccdb.load_ccdb()
		clientid = str(client_address) + ": "

		log.info(f"{clientid}Connected to Auth Server")

		command = client_socket.recv(13)

		log.debug(f":{binascii.b2a_hex(command[1:5])}:")
		log.debug(f":{binascii.b2a_hex(command)}:")

		# if command[1:5] == b"\x00\x00\x00\x00": # \x00 for 2002 beta 1
		# self.process_beta1_packets(clientid, client_socket, client_address, log)
		if command[1:5] == b"\x00\x00\x00\x01":  # \x01 for 2003 beta 2
			self.process_beta2_packets(clientid, client_socket, client_address, log)
		elif command[1:5] == b"\x00\x00\x00\x03":  # \x03 for 2003 release

			log.debug(f"{clientid}Using 2003 auth protocol")
			client_socket.send(b"\x00" + real_socket.inet_aton(client_address[0]))
			log.debug((str(real_socket.inet_aton(client_address[0]))))
			log.debug((str(real_socket.inet_ntoa(real_socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen()

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1]).decode('latin-1')}")
				userblob = {}

				username = command[3:3 + usernamelen]
				username = username
				if os.path.isfile("files/users/" + username.decode() + ".py"):
					with open("files/users/" + username.decode() + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == b"0001":
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen()
						steamtime = utils.unixtime_to_steamtime(time.time())
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen()
						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"04040404"):
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read()
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

						def without_keys(d, keys2):
							return {x:d[x] for x in d if x not in keys2}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						# print(execdict)
						# print(execdict_new)
						# blob = utils.blob_serialize(execdict)
						blob = blobs.blob_serialize(execdict_new2)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = binascii.a2b_hex("12899c8312213a123321321321543344")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
						currtime = time.time()
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']

						# TODO BEN, GRAB FROM DIR SERVER
						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						# bin_ip = utils.encodeIP(("172.21.0.20", "27039"))
						servers = bin_ip + bin_ip

						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
						log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						clientIP = real_socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80)  # TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						subcommand1 = b"\x00\x01"  # for TGT v1
						subcommand2 = b""  # missing for TGT v1
						empty2_dec_len = b"\x00\x42"
						empty2_enc_len = b"\x00\x50"
						# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
						data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
						data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if wrongpass == "1":
							tgt_command = b"\x00"  # Incorrect password
						else:
							tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time())
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time())
					tgt_command = b"\x00"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[14:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b"\x01\x00\x00\x00"]))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x01")
							if self.config["smtp_enabled"].lower() == "true":
								send_password_changed_email(userblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x00")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[14:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob [b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x01")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x00")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]
				new_email_addr = blob[:-padding_byte]
				new_email_addr += b"\x00"

				userblob = {}
				execdict_new = {}
				execdict_new2 = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b'\x0b\x00\x00\x00':new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				secretkey2 = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug("Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x13": # Verify email..?
				log.info(f"{clientid}Verify Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x14":
				log.info(f"{clientid}Requested Verification Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x15":
				log.info(f"{clientid}Update Account Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x16":
				log.info(f"{clientid}Update Subscription Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1b":
				log.info(f"{clientid} Recieved Unknown Packet 0x1B - Not Operational")
				log.debug(command)
				client_socket.send(b"\x01")
			elif command[0:1] == b"\x1c":
				log.info(f"{clientid}Change Account Name - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1f":
				log.info(f"{clientid}Generate Suggested Name packet 2 - Not Operational")
				log.debug(command)
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()
				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug("Message verification:" + repr(encryption.verify_message(key, cryptedblob)))
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				pprint.pprint(plainblob)
				client_socket.send("\x01")
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				blobnew = blobs.blob_unserialize(decodedmessage[header :header + blob_len])

				log.info(f"{clientid}Subscribe to package " + str(struct.unpack('<L', blobnew[b'\x01\x00\x00\x00'])[0]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					execdict = {}
					execdict_new = {}
					execdict_new2 = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					steamtime = utils.unixtime_to_steamtime(time.time())
					new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00': steamtime,
										b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
										b'\x03\x00\x00\x00':b'\x00\x00',
										b'\x05\x00\x00\x00':b'\x00',
										b'\x06\x00\x00\x00':b'\x1f\x00'}}
					if b"\x02\x00\x00\x00" in blobnew:
						new_buy = {blobnew[b'\x01\x00\x00\x00']:blobnew[b'\x02\x00\x00\x00']}
					else:
						new_buy = {blobnew[b'\x01\x00\x00\x00']:{}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
					receipt_dict = {}
					receipt_dict_01 = {}
					receipt_sub_dict = {}
					subid = list(new_buy.keys())[0]
					execdict[b'\x07\x00\x00\x00'].update(new_sub)
					# pprint.pprint(new_sub)
					# pprint.pprint(new_buy)
					# pprint.pprint(subid)
					if b"\x02\x00\x00\x00" in blobnew:
						if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"ValveCDKey\x00":
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							# receipt_sub_dict[b'\x02\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00" #should be 8 digit hash of key, FIX ME
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
						else:
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
							receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
							receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
							receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
							receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
							receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
							receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
							receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
							receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999)).encode('ascii') + b'\x00'
							receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
							receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
							receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now().strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now().strftime("%H:%M:%S").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999)).encode('ascii')  + b'\x00'
							receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
					else:
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
						receipt_dict_01[b'\x02\x00\x00\x00'] = {}
						receipt_dict[subid] = receipt_dict_01
					new_buy.clear()
					execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
					execdict_pprint = pprint.pformat(execdict)
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict_pprint))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					# blob = utils.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
					# client_socket.send(b"\x01" + blob_encrypted)
					client_socket.send(blob_encrypted)
			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					execdict_new2 = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					# blob = steam.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug("Blob length: " + str(bloblen))
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature

					client_socket.send(blob_encrypted)
					# print(bloblen)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v2 beta
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time()

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)

				# TODO BEN, GRAB FROM DIR SERVER
				if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
					client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary
				else:
					client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest()

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x0c":
				log.info(f"{clientid}Get Encrypted UserID Ticket To Send To AppServer - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1d":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")
				if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x1e":
				log.info(f"{clientid}Get Suggested names packet")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				suggestedname = utilities.name_suggestor.similar_username_generator(username_str.decode('latin-1'), self.suggestednames_amnt)
				ser_suggestednames = blobs.blob_serialize(suggestedname)
				client_socket.send_withlen(ser_suggestednames)

			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: {email_str}")
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read()
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x23":
				log.info(clientid + "Client Acknowledged Subscription Receipt")
				client_socket.close()
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()
				# print(reply)
				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys):
				#    return {x: d[x] for x in d if x not in keys}

				# ``plainblob_fixed`` = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)

				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid

				invalid7 = {b'\x07\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{
							b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
							b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
							b'\x03\x00\x00\x00':b'\x01\x00', b'\x05\x00\x00\x00':b'\x00',
							b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str.decode() + ".py", 'w') as userblobfile:
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob))

				client_socket.send(b"\x01")
				if self.config['smtp_enabled'].lower() == "true":
					sendmail.send_new_user_email(plainblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')

				if os.path.isfile("files/users/" + username_str.decode() + ".py"):  # NEED TO FIX
					client_socket.send(b"\x01")
					if self.config["smtp_enabled"].lower() == "true":
						self.send_validation_email(username_str.decode('latin-1'), client_address)
				else:
					client_socket.send(b"\x00")

			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				username_str = b""

				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str.decode() + ".py", 'r') as userblobfile:
						userblobstr = userblobfile.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen()

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					padding_byte = dec_blob[-1]
					unser_blob = blobs.blob_unserialize(dec_blob[:-padding_byte])
					while True:
						if self.config["smtp_enabled"].lower() == "true":
							if self.manager.validate_code(unser_blob[b"\x04\x00\x00\x00"].rstrip(b'\x00').decode('latin-1'), username_str.decode('latin-1')):
								pass
							else:
								log.warning(f"{clientid}Validation Code Incorrect for: {username_str}")
								client_socket.send(b"\x00")
								break

						if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
							if (os.path.isfile("files/users/" + username_str.decode() + ".py")):
								with open("files/users/" + username_str.decode() + ".py", 'w') as userblobfile:
									userblobfile.write("user_registry = ")
									userblobfile.write(str(userblob))
								log.info(f"{clientid}Password changed for: {username_str}")
								client_socket.send(b"\x01")
								break
							else:
								log.warning(f"{clientid}SADB file error for: {username_str}")
								client_socket.send(b"\x00")
								break
						else:
							log.warning(f"{clientid}Password change failed for: {username_str}")
							client_socket.send(b"\x00")
							break

				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x00")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x01")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x00")

			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
										if key == key_str:
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x01")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x00")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				blob = cdr_manipulator.fixblobs()
				checksum = SHA.new(blob).digest()

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")
		elif command[1:5] == b"\x00\x00\x00\x04":  # and globalvars.steamui_ver < 336:  # or command[1:5] == b"\x00\x00\x00\x02": #\x04 for 2004-2007

			log.debug(f"{clientid}Using 2004 auth protocol")
			client_socket.send(b"\x00" + real_socket.inet_aton(client_address[0]))
			log.debug((str(real_socket.inet_aton(client_address[0]))))
			log.debug((str(real_socket.inet_ntoa(real_socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen()

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
				userblob = {}

				username = command[3:3 + usernamelen]

				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == b"0001":
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen()
						steamtime = utils.unixtime_to_steamtime(time.time())
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen()

						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"04040404"):
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read()
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						# print(repr(execdict))
						# print(repr(execdict_new))
						# blob = utils.blob_serialize(execdict)
						if globalvars.steamui_ver < 24:
							blob = blobs.blob_serialize(execdict_new2)
						else:
							blob = blobs.blob_serialize(execdict_new)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
						currtime = time.time()
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']

						# TODO grab from directory server
						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						# bin_ip = utils.encodeIP(('192.168.0.185', 27034))
						servers = bin_ip + bin_ip

						currtime = int(currtime)
						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						if globalvars.tgt_version == "1":  # nullData1
							subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
							log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						elif globalvars.tgt_version == "2":
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # v3 Steam
						else:
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # Assume v3 Steam
						clientIP = real_socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						# Calculate data1_len_empty as an integer
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						# Rest of the code remains the same
						data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						if globalvars.tgt_version == "1":
							subcommand1 = b"\x00\x01"  # for TGT v1
							subcommand2 = b""  # missing for TGT v1
							empty2_dec_len = b"\x00\x42"
							empty2_enc_len = b"\x00\x50"
							# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
							data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						elif globalvars.tgt_version == "2":
							subcommand1 = b"\x00\x02"  # for TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						else:
							subcommand1 = b"\x00\x02"  # assume TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if globalvars.steamui_ver < 24:
							if wrongpass == "1":
								tgt_command = b"\x00"  # Incorrect password
							else:
								tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						else:
							# tgt_command = b"\x03" #Clock-skew too far out
							if wrongpass == "1":
								tgt_command = b"\x02"  # Incorrect password
							else:
								tgt_command = b"\x00"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time())
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time())
					tgt_command = b"\x01"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x00")
							if self.config["smtp_enabled"].lower() == "true":
								send_password_changed_email(userblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]
				new_email_addr = blob[:-padding_byte]
				new_email_addr += b"\x00"

				userblob = {}
				execdict_new = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b"\x0b\x00\x00\x00":new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				# TODO BEN, CHECK IF WE SHOULD SEND EMAIL ABOUT THIS!
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x13": # Verify email..?
				log.info(f"{clientid}Verify Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x14":
				log.info(f"{clientid}Requested Verification Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x15":
				log.info(f"{clientid}Update Account Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x16":
				log.info(f"{clientid}Update Subscription Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1b":
				log.info(f"{clientid} Recieved Unknown Packet 0x1B - Not Operational")
				log.debug(command)
				client_socket.send(b"\x01")
			elif command[0:1] == b"\x1c":
				log.info(f"{clientid}Change Account Name - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1f":
				log.info(f"{clientid}Generate Suggested Name packet 2 - Not Operational")
				log.debug(command)
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()
				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug("Message verification:" + repr(encryption.verify_message(key, cryptedblob)))
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				pprint.pprint(plainblob)
				client_socket.send("\x01")
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				blobnew = blobs.blob_unserialize(decodedmessage[header:header + blob_len])

				log.info(f"{clientid}Subscribe to package" + str([struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					steamtime = utils.unixtime_to_steamtime(time.time())

					if b"\x02\x00\x00\x00" in blobnew:
						new_sub = {blobnew[b'\x01\x00\x00\x00']: {b'\x01\x00\x00\x00': steamtime, b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x00\x00', b'\x05\x00\x00\x00': b'\x00', b'\x06\x00\x00\x00': b'\x1f\x00'}}
						new_buy = {blobnew[b'\x01\x00\x00\x00']: blobnew[b'\x02\x00\x00\x00']}
					else:
						log.debug(f"{clientid}Subscribing to default subscription")
						new_sub = {blobnew[b'\x01\x00\x00\x00']: {b'\x01\x00\x00\x00': steamtime, b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x01\x00', b'\x05\x00\x00\x00': b'\x01', b'\x06\x00\x00\x00': b'\x00\x00'}}
						new_buy = {blobnew[b'\x01\x00\x00\x00']: {}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0

					receipt_dict = {}
					receipt_dict_01 = {}
					receipt_sub_dict = {}
					subid = list(new_buy.keys())[0]
					execdict[b'\x07\x00\x00\x00'].update(new_sub)
					# pprint.pprint(new_sub)
					# pprint.pprint(new_buy)
					# pprint.pprint(subid)
					if b"\x02\x00\x00\x00" in blobnew:
						# if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "ValveCDKey\x00":
						if new_buy[subid][b'\x01\x00\x00\x00'] == b"\x02":  # PREPURCHASED
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							# receipt_sub_dict [b'\x02\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4, byteorder='little')  + b"\x00" #should be 8 digit hash of key, FIX ME
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
						elif new_buy[subid][b'\x01\x00\x00\x00'] == b"\x01":  # PAYMENTCARD
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
							receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
							receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
							receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
							receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
							receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
							receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
							receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
							receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999)).encode('ascii') + b'\x00'
							receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
							receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
							receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now().strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now().strftime("%H:%M:%S").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999)).encode('ascii')  + b'\x00'
							receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
					else:
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
						receipt_dict_01[b'\x02\x00\x00\x00'] = {}
						receipt_dict[subid] = receipt_dict_01
					new_buy.clear()
					execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
					execdict_pprint = pprint.pformat(execdict)
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict_pprint))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x: d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)
			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v2 beta
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				# decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time()

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)

				# TODO Get Dynamically from DIR Server?

				if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
					client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"
				else:
					client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # utils.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest()

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x0c":
				log.info(f"{clientid}Get Encrypted UserID Ticket To Send To AppServer  - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1d":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")
				if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x1e":
				log.info(f"{clientid}Get Suggested names packet")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				suggestedname = utilities.name_suggestor.similar_username_generator(username_str.decode('latin-1'), self.suggestednames_amnt)
				ser_suggestednames = blobs.blob_serialize(suggestedname)
				client_socket.send_withlen(ser_suggestednames)

			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: {email_str}")
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read()
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x23":
				log.info(clientid + "Client Acknowledged Subscription Receipt")
				client_socket.close()
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)

				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys):
				#    return {x: d[x] for x in d if x not in keys}

				# plainblob_fixed = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)
				# pprint.pprint(plainblob)

				# if b'\x01\x00\x00\x00' not in plainblob[b'\x06\x00\x00\x00'][username_str]:
				#    plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = None

				# Assign the new value
				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid
				invalid7 = {b'\x07\x00\x00\x00'}

				# pprint.pprint(plainblob)
				def without_keys(d, keys):
					return {x: d[x] for x in d if x not in keys}

				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
							b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
							b'\x03\x00\x00\x00':b'\x01\x00',
							b'\x05\x00\x00\x00':b'\x00',
							b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str.decode('latin-1') + ".py", 'w') as userblobfile:
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob))

				client_socket.send(b"\x00")
				if self.config['smtp_enabled'].lower() == "true":
					sendmail.send_new_user_email(plainblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				if os.path.isfile("files/users/" + username_str.decode() + ".py"):
					client_socket.send(b"\x00")
					if self.config["smtp_enabled"].lower() == "true":
						self.send_validation_email(username_str.decode('latin-1'), client_address)
				else:
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str.decode('latin-1') + ".py", 'r') as userblobfile:
						userblobstr = userblobfile.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen()

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					pad_size = dec_blob[-1]
					unser_blob = blobs.blob_unserialize(dec_blob[:-pad_size])
					pprint.pprint(unser_blob)
					while True:
						if self.config["smtp_enabled"].lower() == "true":
							if self.manager.validate_code(unser_blob[b"\x04\x00\x00\x00"].rstrip(b'\x00').decode('latin-1'), username_str.decode('latin-1')):

								pass
							else:
								log.warning(f"{clientid}Validation Code Incorrect for: {username_str}")
								client_socket.send(b"\x01")
								break

						if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
							if (os.path.isfile("files/users/" + username_str.decode() + ".py")):
								with open("files/users/" + username_str.decode() + ".py", 'w') as userblobfile:
									userblobfile.write("user_registry = ")
									userblobfile.write(str(userblob))
								log.info(f"{clientid}Password changed for: {username_str}")
								client_socket.send(b"\x00")
								break
							else:
								log.warning(f"{clientid}SADB file error for: {username_str}")
								client_socket.send(b"\x01")
								break
						else:
							log.warning(f"{clientid}Password change failed for: {username_str}")
							client_socket.send(b"\x01")
							break
				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x01")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x00")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
										if key == key_str:
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x00")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				blob = cdr_manipulator.fixblobs()
				checksum = SHA.new(blob).digest()

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")
		elif command[1:5] == b"\x00\x00\x00\x05":  # \x04 for 2007+ TEMP SOLUTION FOR DEFAULT SUBSCRIBE ISSUE

			log.debug(f"{clientid}Using 2007 auth protocol")
			client_socket.send(b"\x00" + real_socket.inet_aton(client_address[0]))
			log.debug((str(real_socket.inet_aton(client_address[0]))))
			log.debug((str(real_socket.inet_ntoa(real_socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen()

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
				userblob = {}

				username = command[3:3 + usernamelen]

				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == "0001":
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen()
						steamtime = utils.unixtime_to_steamtime(time.time())
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen()
						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"04040404"):
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read()
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						# print(execdict)
						# print(execdict_new)
						blob = blobs.blob_serialize(execdict)
						if globalvars.steamui_ver < 24:
							blob = blobs.blob_serialize(execdict_new2)
						else:
							blob = blobs.blob_serialize(execdict_new)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
						currtime = time.time()
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']

						# TODO BEN, grab from directory server
						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						# bin_ip = utils.encodeIP(("172.21.0.20", "27039"))
						servers = bin_ip + bin_ip

						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						if globalvars.tgt_version == "1":  # nullData1
							subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
							log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						elif globalvars.tgt_version == "2":
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # v3 Steam
						else:
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # Assume v3 Steam
						clientIP = real_socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						data1_full = data1 + (b"\x00" * (data1_len_empty / 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						if globalvars.tgt_version == "1":
							subcommand1 = b"\x00\x01"  # for TGT v1
							subcommand2 = b""  # missing for TGT v1
							empty2_dec_len = b"\x00\x42"
							empty2_enc_len = b"\x00\x50"
							# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
							data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						elif globalvars.tgt_version == "2":
							subcommand1 = b"\x00\x02"  # for TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						else:
							subcommand1 = b"\x00\x02"  # assume TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if globalvars.steamui_ver < 24:
							if wrongpass == "1":
								tgt_command = b"\x00"  # Incorrect password
							else:
								tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						else:
							# tgt_command = b"\x03" #Clock-skew too far out
							if wrongpass == "1":
								tgt_command = b"\x02"  # Incorrect password
							else:
								tgt_command = b"\x00"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time())
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time())
					tgt_command = b"\x01"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x00")
							if self.config["smtp_enabled"].lower() == "true":
								send_password_changed_email(userblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen()
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				new_email_addr = blob[:-struct.unpack(">B", blob[-1:])[0]] + b"\x00"



				userblob = {}
				execdict_new = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b"\x0b\x00\x00\x00":new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x13": # Verify email..?
				log.info(f"{clientid}Verify Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x14":
				log.info(f"{clientid}Requested Verification Email - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x15":
				log.info(f"{clientid}Update Account Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x16":
				log.info(f"{clientid}Update Subscription Billing Information - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1b":
				log.info(f"{clientid} Recieved Unknown Packet 0x1B - Not Operational")
				log.debug(command)
				client_socket.send(b"\x01")
			elif command[0:1] == b"\x1c":
				log.info(f"{clientid}Change Account Name - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1f":
				log.info(f"{clientid}Generate Suggested Name packet 2 - Not Operational")
				log.debug(command)
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen()
				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug("Message verification:" + repr(encryption.verify_message(key, cryptedblob)))
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				pprint.pprint(plainblob)
				client_socket.send("\x01")
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				# Assuming decodedmessage is a byte-string
				blob = decodedmessage[header:header + blob_len]
				# Slice the dec_blob to remove padding and unserialize
				blobnew = blobs.blob_unserialize(decodedmessage[header:header + struct.unpack(">B", blob[-1:])[0]])

				log.info(f"{clientid}Subscribe to package " + str(struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					execdict = {}
				execdict_new = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
				execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				steamtime = utils.unixtime_to_steamtime(time.time())
				new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00':steamtime,
									b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
									b'\x03\x00\x00\x00':b'\x00\x00', b'\x05\x00\x00\x00':b'\x00',
									b'\x06\x00\x00\x00':b'\x1f\x00'}}
				if b"\x02\x00\x00\x00" in blobnew:
					new_buy = {blobnew[b'\x01\x00\x00\x00']:blobnew[b'\x02\x00\x00\x00']}
				else:
					log.debug(f"{clientid}Subscribing to default subscription")
				new_buy = {blobnew[b'\x01\x00\x00\x00']:{}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				receipt_dict = {}
				receipt_dict_01 = {}
				receipt_sub_dict = {}
				subid = list(new_buy.keys())[0]
				execdict[b'\x07\x00\x00\x00'].update(new_sub)
				# pprint.pprint(new_sub)
				# pprint.pprint(new_buy)
				# pprint.pprint(subid)
				if b"\x02\x00\x00\x00" in blobnew:
					# if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"ValveCDKey\x00" :
					if new_buy[subid][b'\x01\x00\x00\x00'] == b"\x02":  # PREPURCHASED
						receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
						# receipt_sub_dict[b'\x02\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4, byteorder='little') + b"\x00" #should be 8 digit hash of key, FIX ME
						receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
						receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
						receipt_dict[subid] = receipt_dict_01
					elif new_buy[subid][b'\x01\x00\x00\x00'] == b"\x01":  # PAYMENTCARD
						receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
						receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
						receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
						receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
						receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
						receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
						receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
						receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
						receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
						receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999)).encode('ascii') + b'\x00'
						receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
						receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
						receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now().strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
						receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now().strftime("%H:%M:%S").encode("latin-1") + b"\x00"
						receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999)).encode('ascii')  + b'\x00'
						receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
						receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
						receipt_dict[subid] = receipt_dict_01
				else:
					receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
					receipt_dict_01[b'\x02\x00\x00\x00'] = {}
					receipt_dict[subid] = receipt_dict_01
				new_buy.clear()
				execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				# print(execdict)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
				client_socket.send(b"\x00" + blob_encrypted)
			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}


					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}


					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len,0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v1
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time()

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)

				# TODO BEN GRAB ON DIR SERVER

				if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
					client_ticket = utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary
				else:
					client_ticket = utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest()

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x0c":
				log.info(f"{clientid}Get Encrypted UserID Ticket To Send To AppServer - Not Operational")
				log.debug(command)
				client_socket.send("\x01")
			elif command[0:1] == b"\x1d":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")

				# TODO SEND SUGGESTIONS PACKET
				if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x1e":
				log.info(f"{clientid}Get Suggested names packet")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				suggestedname = utilities.name_suggestor.similar_username_generator(username_str.decode('latin-1'), self.suggestednames_amnt)
				ser_suggestednames = blobs.blob_serialize(suggestedname)
				client_socket.send_withlen(ser_suggestednames)
			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: {email_str}")
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read()
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\x01")
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x23":
				log.info(clientid + "Client Acknowledged Subscription Receipt")
				client_socket.close()
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys):
				#    return {x: d[x] for x in d if x not in keys}

				# plainblob_fixed = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)

				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid

				invalid7 = {b'\x07\x00\x00\x00'}


				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}


				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
																	b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
																	b'\x03\x00\x00\x00':b'\x01\x00', b'\x05\x00\x00\x00':b'\x00',
																	b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str + ".py", 'w') as userblobfile:
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob_fixed))

				client_socket.send(b"\x00")
				if self.config['smtp_enabled'].lower() == "true":
					sendmail.send_new_user_email(plainblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				if os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py"):
					client_socket.send(b"\x00")
					if self.config["smtp_enabled"].lower() == "true":
						self.send_validation_email(username_str.decode('latin-1'), client_address)
				else:
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str + ".py", 'r') as userblobfile:
						userblobstr = userblobfile.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen()

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					unser_blob = blobs.blob_unserialize(dec_blob[:-dec_blob[-1]])
					while True:
						if self.config["smtp_enabled"].lower() == "true":
							if self.manager.validate_code(unser_blob[b"\x04\x00\x00\x00"].rstrip(b'\x00').decode('latin-1'), username_str.decode('latin-1')):
								pass
							else:
								log.warning(f"{clientid}Validation Code Incorrect for: {username_str}")
								client_socket.send(b"\x01")
								break

						if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
							userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
							if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
								with open("files/users/" + username_str + ".py", 'w') as userblobfile:
									userblobfile.write("user_registry = ")
									userblobfile.write(str(userblob))
								log.info(f"{clientid}Password changed for: {username_str}")
								client_socket.send(b"\x00")
								break
							else:
								log.warning(f"{clientid}SADB file error for: {username_str}")
								client_socket.send(b"\x01")
								break
						else:
							log.warning(f"{clientid}Password change failed for: {username_str}")
							client_socket.send(b"\x01")
							break
				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x01")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x00")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen()

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read()
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
										if key == key_str:
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x00")
						if self.config["smtp_enabled"].lower() == "true":
							self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				blob = cdr_manipulator.fixblobs()

				checksum = SHA.new(blob).digest()

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")
		else:
			data = client_socket.recv(65535)
			log.warning(f"{clientid}Invalid command: {binascii.b2a_hex(command[1:5])}")
			log.warning(f"{clientid}Extra data: {binascii.b2a_hex(data)}")

		client_socket.close()
		log.info(f"{clientid}Disconnected from Auth Server")

	def send_validation_email(self, username_str, client_address):
		if isinstance(username_str, bytes):
			username_str = username_str.decode('latin-1')
		# Send Email Verification Code and Password Recoveru Qiuestion
		with open("files/users/" + username_str + ".py", 'r') as userblobfile:
			userblobstr = userblobfile.read()
			userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])

		new_code = self.manager.generate_code(username_str)
		sendmail.send_reset_password_email(userblob[b'\x0b\x00\x00\x00'].decode('latin-1'), new_code, userblob[b'\x05\x00\x00\x00'][username_str.encode('latin-1')][b'\x03\x00\x00\x00'], client_address, username_str.decode('latin-1'))

	def process_beta2_packets(self, clientid, client_socket, client_address, log):
		log.debug(f"{clientid}Using 2003 beta auth protocol")
		client_socket.send(b"\x00" + real_socket.inet_aton(client_address[0]))
		log.debug((str(real_socket.inet_aton(client_address[0]))))
		log.debug((str(real_socket.inet_ntoa(real_socket.inet_aton(client_address[0])))))
		command = client_socket.recv_withlen()
		if command[0:1] == b"\x02":  # LOGIN

			usernamelen = struct.unpack(">H", command[1:3])[0]
			log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
			userblob = {}

			username = command[3:3 + usernamelen]

			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				# print(userblob)
				blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
				if blocked == b"0001":
					log.info(f"{clientid}Blocked user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					command = client_socket.recv_withlen()
					steamtime = utils.unixtime_to_steamtime(time.time())
					tgt_command = b"\x04"  # BLOCKED
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
				else:
					personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
					# print(personalsalt)
					client_socket.send(personalsalt)  # NEW SALT PER USER
					command = client_socket.recv_withlen()
					key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
					# print(binascii.b2a_hex(key))
					IV = command[0:16]
					# print(binascii.b2a_hex(IV))
					encrypted = command[20:36]
					# print(binascii.b2a_hex(encrypted))
					decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
					log.debug(f"{clientid}Authentication package: {decodedmessage}")

					if not decodedmessage.endswith(b"04040404"):
						wrongpass = "1"
						log.info(f"{clientid}Incorrect password entered for: {username}")
					else:
						wrongpass = "0"

					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read()
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					# blob = steam.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
					currtime = time.time()
					outerIV = binascii.a2b_hex("92183129534234231231312123123353")
					steamUniverse = struct.pack(">H", int(self.config["universe"]))
					steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']
					if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
						bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
					else:
						bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
					servers = bin_ip + bin_ip
					times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(currtime + (60 * 60 * 24 * 28))
					subheader = innerkey + steamid + servers + times
					subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
					subhead_decr_len = b"\x00\x36"
					subhead_encr_len = b"\x00\x40"
					subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
					log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
					clientIP = real_socket.inet_aton(client_address[0])
					publicIP = clientIP[::-1]
					# subcommand3 = b"\x00\x00\x00\x00"
					data1_len_str = b"\x00\x80"
					# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
					data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
					data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
					data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
					empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
					username_len = len(username)
					# username_len_packed = struct.pack(">H", 50 + username_len)
					accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
					data2 = struct.pack(">L", len(username))
					subcommand1 = b"\x00\x01"  # for TGT v1
					subcommand2 = b""  # missing for TGT v1
					empty2_dec_len = b"\x00\x42"
					empty2_enc_len = b"\x00\x50"
					# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
					data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
					data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

					# empty2 = username + empty2_empty[(len(username)):]
					real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
					real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
					# ticket = subheader_encrypted + unknown_part + blob_encrypted
					ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

					ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

					if wrongpass == "1":
						tgt_command = b"\x00"  # Incorrect password
					else:
						tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
					steamtime = utils.unixtime_to_steamtime(time.time())
					clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
					authenticate = tgt_command + steamtime + clock_skew_tolerance
					writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
					client_socket.send(authenticate + writeAccountInformation)
					# print(bloblen)

			else:
				log.info(f"{clientid}Unknown user: {username}")
				client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
				steamtime = utils.unixtime_to_steamtime(time.time())
				tgt_command = b"\x00"  # UNKNOWN USER
				padding = b"\x00" * 1222
				ticket_full = tgt_command + steamtime + padding
				client_socket.send(ticket_full)
		elif command[0:1] == b"\x10":  # Change password
			# log.info(f"{clientid}Change password")

			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

			log.info(f"{clientid}Password change requested for: {username}")

			userblob = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			# print(personalsalt)
			client_socket.send(personalsalt)  # NEW SALT PER USER
			blobtext = client_socket.recv_withlen()
			key = binascii.a2b_hex("10231230211281239191238542314233")
			IV = secrets.token_bytes(16)
			crypted_blob = blobtext[10:]
			if repr(encryption.verify_message(key, crypted_blob)):
				plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
				blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
				blob_len = len(plaintext) - 16 - blob_len
				blob = blobs.blob_unserialize(plaintext[16:-blob_len])
				# print(blob)
				# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
				# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
				if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
					userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
					if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
						with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
							userblobfile.write("user_registry = ")
							userblobfile.write(str(userblob))
						log.info(f"{clientid}Password changed for: {username}")
						client_socket.send(b"\x00")
					if self.config["smtp_enabled"].lower() == "true":
						send_password_changed_email(userblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
					else:
						log.warning(f"{clientid}SADB file error for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			else:
				log.warning(f"{clientid}Password change failed for: {username}")
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x11":  # Change question
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

			log.info(f"{clientid}Secret question change requested for: {username}")

			userblob = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			# print(personalsalt)
			client_socket.send(personalsalt)  # NEW SALT PER USER
			blobtext = client_socket.recv_withlen()
			key = binascii.a2b_hex("10231230211281239191238542314233")
			IV = secrets.token_bytes(16)
			crypted_blob = blobtext[10:]
			if repr(encryption.verify_message(key, crypted_blob)):
				plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
				blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
				blob_len = len(plaintext) - 16 - blob_len
				blob = blobs.blob_unserialize(plaintext[16:-blob_len])
				# print(blob)
				# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
				# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
				if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
					userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
					if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
						with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
							userblobfile.write("user_registry = ")
							userblobfile.write(str(userblob))
						log.info(f"{clientid}Secret question changed for: {username}")
						client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}SADB file error for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			else:
				log.warning(f"{clientid}Secret question change failed for: {username}")
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x12":  # Change email
			log.info(f"{clientid}Change email")
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
			blob_len = (blob_len[0])
			blob = (decodedmessage[header:header + blob_len])
			new_email_addr = blob[:-blob[-1]] + b"\x00"
			userblob = {}
			execdict_new = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			new_email = {}
			new_email = {b"\x0b\x00\x00\x00":new_email_addr}
			userblob.update(new_email)
			with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
				g.write("user_registry = " + str(userblob))
			secretkey = {b'\x05\x00\x00\x00'}

			def without_keys(d, keys):
				return {x:d[x] for x in d if x not in keys}

			execdict_new = without_keys(userblob, secretkey)
			# print(userblob)
			# print(execdict_new)
			blob = blobs.blob_serialize(execdict_new)
			# print(blob)
			bloblen = len(blob)
			log.debug(f"Blob length: {str(bloblen)}")
			innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
			# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
			innerIV = userIV
			blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
			blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
			blob_signature = encryption.sign_message(innerkey, blob_encrypted)
			blob_encrypted_len = 10 + len(blob_encrypted) + 20
			blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
			ticket = ticket + blob_encrypted
			ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
			client_socket.send(b"\x00" + blob_encrypted + blob_signature)
		elif command[0:1] == b"\x05":  # Subscribe
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
			blob_len = (blob_len[0])
			blob = (decodedmessage[header:header + blob_len])
			padding_byte = blob[-1:]
			padding_int = struct.unpack(">B", padding_byte)
			blobnew = blobs.blob_unserialize(decodedmessage[header:header + blob_len])
			log.info(f"{clientid}Subscribe to package " + str(struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				execdict = {}
				execdict_new = {}
				execdict_new2 = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				steamtime = utils.unixtime_to_steamtime(time.time())
				new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00':steamtime,
														 b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
														 b'\x03\x00\x00\x00':b'\x00\x00', b'\x05\x00\x00\x00':b'\x00',
														 b'\x06\x00\x00\x00':b'\x1f\x00'}}
				# if b"\x02\x00\x00\x00" in blobnew:
				#    new_buy = {blobnew[b'\x01\x00\x00\x00']: blobnew[b'\x02\x00\x00\x00']}
				# else:
				#    new_buy = {blobnew[b'\x01\x00\x00\x00']: {}} #SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				# receipt_dict = {}
				# receipt_dict_01 = {}
				# receipt_sub_dict = {}
				# subid = new_buy.keys()[0]
				execdict[b'\x07\x00\x00\x00'].update(new_sub)
				# pprint.pprint(new_sub)
				# pprint.pprint(new_buy)
				# pprint.pprint(subid)
				# if b"\x02\x00\x00\x00" in blobnew:
				#    if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "ValveCDKey\x00":
				#        receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
				#        #receipt_sub_dict[b'\x02\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00" #should be 8 digit hash of key, FIX ME
				#        receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00" #saving key for now for verification
				#        receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
				#        receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
				#        receipt_dict[subid] = receipt_dict_01
				#    else:
				#        receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
				#        receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
				#        receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
				#        receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
				#        receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
				#        receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
				#        receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
				#        receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
				#        receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
				#        receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999)) + b"\x00"
				#        receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
				#        receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
				#        receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now().strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
				#        receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now().strftime("%H:%M:%S").encode("latin-1") + b"\x00"
				#        receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00"
				#        receipt_sub_dict[b'\x13\x00\x00\x00'] = "\x00\x00\x00\x00"
				#        receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
				#        receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
				#        receipt_dict[subid] = receipt_dict_01
				# else:
				#    receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07" #SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				#    receipt_dict_01[b'\x02\x00\x00\x00'] = {}
				#    receipt_dict[subid] = receipt_dict_01
				# new_buy.clear()
				# execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

				def without_keys(d, keys2):
					return {x:d[x] for x in d if x not in keys2}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(execdict)
				# print(execdict_new)
				# blob = blobs.blob_serialize(execdict)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
				# client_socket.send(b"\x01" + blob_encrypted)
				client_socket.send(blob_encrypted)
		elif command[0:1] == b"\x06":  # Unsubscribe
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			padding_byte = decodedmessage[-1:]
			padding_int, = struct.unpack(">B", padding_byte)
			sub_id, = struct.unpack("<L", decodedmessage[header:-padding_int])
			log.info(f"{clientid}Unsubscribe from package " + str(sub_id))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				execdict = {}
				execdict_new = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				del execdict[b'\x07\x00\x00\x00'][struct.pack("<L", sub_id)]
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}

				def without_keys(d, keys2):
					return {x:d[x] for x in d if x not in keys2}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				blob = blobs.blob_serialize(execdict_new2)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
				client_socket.send(blob_encrypted)
		elif command[0:1] == b"\x09":  # Ticket Login/refresh games list
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}Ticket login for: {username}")
			ticket_len = int(ticket_len, 16) * 2
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			# decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				# client_socket.send(b"\x00")
				# create login ticket
				execdict = {}
				execdict_new = {}
				execdict_new2 = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				for sub_dict in execdict:
					if sub_dict == b"\x07\x00\x00\x00":
						for sub_sub_dict in execdict[sub_dict]:
							if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
								execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
								execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
								execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(execdict)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
				# client_socket.send(b"\x00" + blob_encrypted)
				client_socket.send(blob_encrypted)

				execdict = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read()
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				for sub_dict in execdict:
					if sub_dict == b"\x07\x00\x00\x00":
						for sub_sub_dict in execdict[sub_dict]:
							if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
								# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
								execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
								# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict))
		elif command[0:1] == b"\x04":  # Logout
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}User {username} logged out")
		elif command[0:1] == b"\x0a":  # Request content ticket Steam beta 2003
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}Content login for: {username}")
			ticket_len = int(ticket_len, 16) * 2
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			# ------------------------------------------------------------------

			# Incompatible ContentTicket VersionNum
			# u16SizeOfPlaintextClientReadableContentTicket
			# Bad u16SizeOfAESEncryptedClientReadableContentTicket

			# u16SizeOfServerReadableContentTicket

			currtime = time.time()

			client_ticket = b"\x69" * 0x10  # key used for MAC signature
			client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
			client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
			client_ticket += os.urandom(4)  # struct.pack("<I", 1)
			client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)

			# TODO BEN GRAB FROM DIR SERVER
			if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
				client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary
			else:
				client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

			server_ticket = b"\x55" * 0x80

			innerIV = secrets.token_bytes(16)

			client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

			ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted  # FOR BETA 2003
			ticket += struct.pack(">H", len(server_ticket)) + server_ticket

			# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
			ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest()

			client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
		elif command[0:1] == b"\x1d":  # Check username - new user
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)
			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)
			username = plainblob[b'\x01\x00\x00\x00']
			username_str = username.rstrip(b'\x00')
			# print(len(username_str))
			log.info(f"{clientid}New user: check username exists: {username_str}")
			# TODO BEN SEND SUGGESTED NAMES IF NAME EXISTS
			if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
				log.warning(f"{clientid}New user: username already exists")
				client_socket.send(b"\x01")
			else:
				log.info(f"{clientid}New user: username not found")
				client_socket.send(b"\x00")
		elif command[0:1] == b"\x1e":
			log.info(f"{clientid}Get Suggested names packet")
			self.send_mainkey(client_socket)

			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)
			username = plainblob[b'\x01\x00\x00\x00']
			username_str = username.rstrip(b'\x00')

			suggestedname = utilities.name_suggestor.similar_username_generator(username_str.decode('latin-1'), self.suggestednames_amnt)
			ser_suggestednames = blobs.blob_serialize(suggestedname)
			client_socket.send_withlen(ser_suggestednames)

		elif command[0:1] == b"\x22":  # Check email - new user
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)

			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)
			email = plainblob[b'\x01\x00\x00\x00']
			email_str = email.rstrip(b'\x00')
			# print(len(username_str))
			log.info(f"{clientid}New user: check email exists: {email_str}")
			email_exists = False
			for file in os.listdir("files/users/"):
				if file.endswith("py"):
					with open("files/users/" + file, 'r') as f:
						userblobstr = f.read()
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					email_addr = userblob[b'\x0b\x00\x00\x00']
					if email_addr.rstrip(b'\x00') == email_str:
						email_exists = True
						break
			if email_exists:
				log.warning(f"{clientid}New user: email already in use")
				client_socket.send(b"\x01")
			else:
				log.info(f"{clientid}New user: email ok to use")
				client_socket.send(b"\x00")
		elif command[0:1] == b"\x23":
			log.info(clientid + "Client Acknowledged Subscription Receipt")
			client_socket.close()
		elif command[0:1] == b"\x01":  # New user
			log.info(f"{clientid}New user: Create user")
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)

			reply = client_socket.recv_withlen()
			encr_key_len, = struct.unpack(">H", reply[0:2])
			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

			# encr_key = reply[2:2 + encr_key_len]
			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)

			username = plainblob[b'\x01\x00\x00\x00']
			username_str = username.rstrip(b'\x00')

			# invalid6 = {b'\x06\x00\x00\x00'}
			# def without_keys(d, keys):
			#    return {x: d[x] for x in d if x not in keys}

			# plainblob_fixed = without_keys(plainblob, invalid6)

			# dict6 = {}
			# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

			# plainblob_fixed.update(dict6)

			newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
			plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid
			plainblob[b'\x0f\x00\x00\x00'] = {}  # adding for subscribe support

			plainblob_fixed = pprint.pformat(plainblob)

			with open("files/users/" + username_str.decode('latin-1') + ".py", 'w') as userblobfile:
				userblobfile.write("user_registry = ")
				userblobfile.write(str(plainblob))

			client_socket.send(b"\x01")  # TO DO SEND \x00 FOR EMAIL IN USE
		if self.config['smtp_enabled'].lower() == "true":
			sendmail.send_new_user_email(plainblob[b'\x0b\x00\x00\x00'], client_address, username.decode('latin-1'))
		elif command[0:1] == b"\x0e":  # Check username - password reset
			log.info(f"{clientid}Password reset: check username exists")
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)
			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			blobdict = blobs.blob_unserialize(plaintext)
			# print(blobdict)
			usernamechk = blobdict[b'\x01\x00\x00\x00']
			username_str = usernamechk.rstrip(b'\x00')
			if os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py"):
				client_socket.send(b"\x00")
				if self.config["smtp_enabled"].lower() == "true":
					self.send_validation_email(username_str.decode('latin-1'), client_address)
			else:
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x0f":  # Reset password
			log.info(f"{clientid}Password reset by client")
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)
			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				with open("files/users/" + username_str + ".py", 'r') as userblobfile:
					userblobstr = userblobfile.read()
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				# print(userblob)
				questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
				# print(questionsalt)
				client_socket.send(questionsalt)  # USER'S QUESTION SALT
				reply2 = client_socket.recv_withlen()

				header = reply2[0:2]
				enc_len = reply2[2:6]
				zeros = reply2[6:10]
				blob_len = reply2[10:14]
				innerIV = reply2[14:30]
				enc_blob = reply2[30:-20]
				sig = reply2[-20:]
				dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
				padding_byte = dec_blob[-1:]
				padding_int = struct.unpack(">B", padding_byte)
				unser_blob = blobs.blob_unserialize(dec_blob[:-padding_int[0]])
				while True:
					if self.config["smtp_enabled"].lower() == "true":
						if self.manager.validate_code(unser_blob[b"\x04\x00\x00\x00"].rstrip(b'\x00').decode('latin-1'), username_str.decode('latin-1')):
							pass
						else:
							log.warning(f"{clientid}Validation Code Incorrect for: {username_str}")
							client_socket.send(b"\x01")
							break

					if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username_str.decode('latin-1') + ".py")):
							with open("files/users/" + username_str + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username_str}")
							client_socket.send(b"\x00")
							break
						else:
							log.warning(f"{clientid}SADB file error for: {username_str}")
							client_socket.send(b"\x01")
							break
					else:
						log.warning(f"{clientid}Password change failed for: {username_str}")
						client_socket.send(b"\x01")
						break
			else:
				log.warning(f"{clientid}Password change message could not be decrypted")
				client_socket.send(b"\x01")

			reply = {}
			reply2 = {}
		elif command[0:1] == b"\x20":  # Check email - password reset
			log.info(f"{clientid}Password reset by email")
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)
			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				emailchk = blobdict[b'\x01\x00\x00\x00']
				email_str = emailchk.rstrip(b'\x00')
				email_found = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read()
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_found = True
							break
				if email_found:
					client_socket.send(b"\x00")
					if self.config["smtp_enabled"].lower() == "true":
						self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
				else:
					client_socket.send(b"\x01")
		elif command[0:1] == b"\x21":  # Check key - password reset
			log.info(f"{clientid}Password reset by CD key")
			BERstring = bytes.fromhex("30819d300d06092a864886f70d010101050003818b0030818702818100") + encryption.network_key.n.to_bytes(128, byteorder="big") + bytes.fromhex("020111")
			signature = pkcs1_15.new(encryption.network_key).sign(SHA1.new(BERstring))
			reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
			client_socket.send(reply)
			reply = client_socket.recv_withlen()

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				keychk = blobdict[b'\x01\x00\x00\x00']
				key_str = keychk.rstrip(b'\x00')
				key_found = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read()
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						for sub in userblob[b'\x0f\x00\x00\x00']:
							for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
								if prodcdkey == b"\x06":
									key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
									if key == key_str:
										key_found = True
										break
				if key_found:
					client_socket.send(b"\x00")
					if self.config["smtp_enabled"].lower() == "true":
						self.send_validation_email(userblob[b'\x01\x00\x00\x00'].rstrip(b'\x00').decode('latin-1'), client_address)
				else:
					client_socket.send(b"\x01")
		elif command[0:1] == b"\x0b":  # Send CDR for v2 beta

			blob = cdr_manipulator.fixblobs()
			checksum = SHA.new(blob).digest()

			if checksum == command[1:]:
				log.info(f"{clientid}Client has matching checksum for secondblob")
				log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

				client_socket.send(b"\x00\x00\x00\x00")

			else:
				log.info(f"{clientid}Client didn't match our checksum for secondblob")
				log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

				client_socket.send_withlen(blob, True)  # false for not showing in log
		else:
			log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
			client_socket.send(b"\x01")