import ast
import binascii
import datetime
import hashlib
import hmac
import logging
import os
import pprint
import random
import secrets
import shutil
import socket
import struct
import time
import zlib
import ipcalc
from Crypto.Hash import SHA

import globalvars
import utilities.encryption as encryption
import utils

from utilities import cdr_manipulator
from utilities import blobs
from utilities.database import ccdb
from utilities.networkhandler import TCPNetworkHandler


class authserver(TCPNetworkHandler):
	def __init__(self, port, config):
		self.server_type = "AuthServer"
		self.innerkey = binascii.a2b_hex("10231230211281239191238542314233")
		# Create an instance of NetworkHandler
		super(authserver, self).__init__(config, port, self.server_type)

	def handle_client(self, client_socket, client_address):

		log = logging.getLogger(self.server_type)
		# Load this everytime a client connects, this ensures that we can change the blob without restarting the server
		firstblob = ccdb.load_ccdb( )
		clientid = str(client_address) + ": "

		log.info(f"{clientid}Connected to Auth Server")

		command = client_socket.recv(13)

		log.debug(f":{binascii.b2a_hex(command[1:5])}:")
		log.debug(f":{binascii.b2a_hex(command)}:")

		if command[1:5] == b"\x00\x00\x00\x01":  # \x01 for 2003 beta

			self.process_beta2_packets(clientid, client_socket, client_address, log)

		elif command[1:5] == b"\x00\x00\x00\x03":  # \x03 for 2003 release

			log.debug(f"{clientid}Using 2003 auth protocol")
			client_socket.send(b"\x00" + socket.inet_aton(client_address[0]))
			log.debug((str(socket.inet_aton(client_address[0]))))
			log.debug((str(socket.inet_ntoa(socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen( )

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1]).decode('latin-1')}")
				userblob = {}

				username = command[3:3 + usernamelen]
				username = username
				if os.path.isfile("files/users/" + username.decode( ) + ".py") :
					with open("files/users/" + username.decode( ) + ".py", 'r') as f :
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == b"0001" :
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen( )
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen( )
						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][
							  0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"04040404"):
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read( )
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

						def without_keys(d, keys2):
							return {x:d[x] for x in d if x not in keys2}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						# print(execdict)
						# print(execdict_new)
						# blob = utils.blob_serialize(execdict)
						blob = blobs.blob_serialize(execdict_new2)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																										   blob_encrypted_len,
																										   0) + blob_encrypted + blob_signature
						currtime = time.time( )
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']
						# servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
						# authport = struct.pack("<L", int(port))

						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))

						# bin_ip = utils.encodeIP(("172.21.0.20", "27039"))
						servers = bin_ip + bin_ip
						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
						log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						clientIP = socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						subcommand1 = b"\x00\x01"  # for TGT v1
						subcommand2 = b""  # missing for TGT v1
						empty2_dec_len = b"\x00\x42"
						empty2_enc_len = b"\x00\x50"
						# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
						data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
						data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if wrongpass == "1":
							tgt_command = b"\x00"  # Incorrect password
						else:
							tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L",
															  len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					tgt_command = b"\x00"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[14:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b"\x01\x00\x00\x00"]))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x01")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x00")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[14:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob [b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x01")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x00")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]
				new_email_addr = blob[:-padding_byte]
				new_email_addr += b"\x00"

				userblob = {}
				execdict_new = {}
				execdict_new2 = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b'\x0b\x00\x00\x00':new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				secretkey2 = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug("Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex(
					"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																								   blob_encrypted_len,
																								   0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]

				blobnew = blobs.blob_unserialize(decodedmessage[header :header + blob_len])
				log.info(f"{clientid}Subscribe to package " + str(struct.unpack('<L', blobnew[b'\x01\x00\x00\x00'])[0]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					execdict = {}
					execdict_new = {}
					execdict_new2 = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00':steamtime,
															 b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
															 b'\x03\x00\x00\x00':b'\x00\x00',
															 b'\x05\x00\x00\x00':b'\x00',
															 b'\x06\x00\x00\x00':b'\x1f\x00'}}
					if b"\x02\x00\x00\x00" in blobnew:
						new_buy = {blobnew[b'\x01\x00\x00\x00']:blobnew[b'\x02\x00\x00\x00']}
					else:
						new_buy = {blobnew[b'\x01\x00\x00\x00']:{}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
					receipt_dict = {}
					receipt_dict_01 = {}
					receipt_sub_dict = {}
					subid = list(new_buy.keys( ))[0]
					execdict[b'\x07\x00\x00\x00'].update(new_sub)
					# pprint.pprint(new_sub)
					# pprint.pprint(new_buy)
					# pprint.pprint(subid)
					if b"\x02\x00\x00\x00" in blobnew:
						if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"ValveCDKey\x00":
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							# receipt_sub_dict[b'\x02\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00" #should be 8 digit hash of key, FIX ME
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
						else:
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
							receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
							receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
							receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
							receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
							receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
							receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
							receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
							receipt_sub_dict[b'\x0d\x00\x00\x00'] = random.randint(111111, 999999).to_bytes(3,byteorder='little') + b"\x00"
							receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
							receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
							receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now( ).strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now( ).strftime("%H:%M:%S").encode("latin-1") + b"\x00"
							receipt_sub_dict[b'\x12\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4,byteorder='little') + b"\x00"
							receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
					else:
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
						receipt_dict_01[b'\x02\x00\x00\x00'] = {}
						receipt_dict[subid] = receipt_dict_01
					new_buy.clear( )
					execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
					execdict_pprint = pprint.pformat(execdict)
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict_pprint))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					# blob = utils.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																									   blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature
					# client_socket.send(b"\x01" + blob_encrypted)
					client_socket.send(blob_encrypted)
			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					execdict_new2 = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					##blob = steam.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug("Blob length: " + str(bloblen))
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																									   blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature

					client_socket.send(blob_encrypted)
					# print(bloblen)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v2 beta
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time( )

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)

				if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
					client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary
				else:
					client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest( )

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x1d" or command[0:1] == b"\x1e":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")
				if (os.path.isfile("files/users/" + username_str + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: {email_str}")
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read( )
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists == True:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )
				print(reply)
				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys) :
				#    return {x: d[x] for x in d if x not in keys}

				# plainblob_fixed = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)

				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid

				invalid7 = {b'\x07\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{
					b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
										 b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
										 b'\x03\x00\x00\x00':b'\x01\x00', b'\x05\x00\x00\x00':b'\x00',
										 b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {
					b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str.decode( ) + ".py", 'w') as userblobfile :
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob))

				client_socket.send(b"\x01")
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				if os.path.isfile("files/users/" + username_str.decode( ) + ".py") :  # NEED TO FIX
					client_socket.send(b"\x01")
				else:
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				username_str = b""

				if repr(encryption.verify_message(key, cryptedblob)) :
					plaintext_length = struct.unpack("<L", cryptedblob[0 :4])[0]
					IV = cryptedblob[4 :20]
					ciphertext = cryptedblob[20 :-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str.decode( ) + ".py", 'r') as userblobfile :
						userblobstr = userblobfile.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen( )

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					padding_byte = dec_blob[-1]
					unser_blob = blobs.blob_unserialize(dec_blob[:-padding_byte])

					if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][
						b'\x04\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[
							b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[
							b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username_str.decode( ) + ".py")) :
							with open("files/users/" + username_str.decode( ) + ".py", 'w') as userblobfile :
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username_str}")
							client_socket.send(b"\x01")
						else:
							log.warning(f"{clientid}SADB file error for: {username_str}")
							client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}Password change failed for: {username_str}")
						client_socket.send(b"\x00")
				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x00")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x01")
					else:
						client_socket.send(b"\x00")
			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][
												  b'\x02\x00\x00\x00'][:-1]
										if key == key_str:
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x01")
					else:
						client_socket.send(b"\x00")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				blob = cdr_manipulator.fixblobs( )
				checksum = SHA.new(blob).digest( )

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")

		elif command[1:5] == b"\x00\x00\x00\x04": # and globalvars.steamui_ver < 336:  # or command[1:5] == b"\x00\x00\x00\x02" : #\x04 for 2004-2007

			log.debug(f"{clientid}Using 2004 auth protocol")
			client_socket.send(b"\x00" + socket.inet_aton(client_address[0]))
			log.debug((str(socket.inet_aton(client_address[0]))))
			log.debug((str(socket.inet_ntoa(socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen( )

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
				userblob = {}

				username = command[3:3 + usernamelen]

				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == b"0001":
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen( )
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen( )

						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0 :16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"\x04\x04\x04\x04") :
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read( )
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						#print(repr(execdict))
						#print(repr(execdict_new))
						# blob = utils.blob_serialize(execdict)
						if globalvars.steamui_ver < 24:
							blob = blobs.blob_serialize(execdict_new2)
						else:
							blob = blobs.blob_serialize(execdict_new)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																										   blob_encrypted_len,
																										   0) + blob_encrypted + blob_signature
						currtime = time.time( )
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']
						# servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
						# authport = struct.pack("<L", int(port))
						# TODO grab from directory server
						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
						# bin_ip = utils.encodeIP(("172.21.0.20", "27039"))
						servers = bin_ip + bin_ip
						currtime = int(currtime)
						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(
								currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						if globalvars.tgt_version == "1":  # nullData1
							subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
							log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						elif globalvars.tgt_version == "2":
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # v3 Steam
						else:
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # Assume v3 Steam
						clientIP = socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						# Calculate data1_len_empty as an integer
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						# Rest of the code remains the same
						data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						if globalvars.tgt_version == "1":
							subcommand1 = b"\x00\x01"  # for TGT v1
							subcommand2 = b""  # missing for TGT v1
							empty2_dec_len = b"\x00\x42"
							empty2_enc_len = b"\x00\x50"
							# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
							data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						elif globalvars.tgt_version == "2":
							subcommand1 = b"\x00\x02"  # for TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						else:
							subcommand1 = b"\x00\x02"  # assume TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if globalvars.steamui_ver < 24:
							if wrongpass == "1":
								tgt_command = b"\x00"  # Incorrect password
							else:
								tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						else:
							# tgt_command = b"\x03" #Clock-skew too far out
							if wrongpass == "1":
								tgt_command = b"\x02"  # Incorrect password
							else:
								tgt_command = b"\x00"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L",
															  len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					tgt_command = b"\x01"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]
				new_email_addr = blob[:-padding_byte]
				new_email_addr += b"\x00"

				userblob = {}
				execdict_new = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b"\x0b\x00\x00\x00":new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex(
					"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																								   blob_encrypted_len,
																								   0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])
				padding_byte = blob[-1]

				blobnew = blobs.blob_unserialize(decodedmessage[header:header + blob_len])
				log.info(f"{clientid}Subscribe to package" + str([struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode( ) + ".py")) :
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16 :len(userblobstr)])
					steamtime = utils.unixtime_to_steamtime(time.time( ))

					if b"\x02\x00\x00\x00" in blobnew :
						new_sub = {blobnew[b'\x01\x00\x00\x00']: {b'\x01\x00\x00\x00': steamtime, b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x00\x00', b'\x05\x00\x00\x00': b'\x00', b'\x06\x00\x00\x00': b'\x1f\x00'}}
						new_buy = {blobnew[b'\x01\x00\x00\x00'] : blobnew[b'\x02\x00\x00\x00']}
					else :
						log.debug(f"{clientid}Subscribing to default subscription")
						new_sub = {blobnew[b'\x01\x00\x00\x00']: {b'\x01\x00\x00\x00': steamtime, b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x01\x00', b'\x05\x00\x00\x00': b'\x01', b'\x06\x00\x00\x00': b'\x00\x00'}}
						new_buy = {blobnew[b'\x01\x00\x00\x00'] : {}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0

					receipt_dict = {}
					receipt_dict_01 = {}
					receipt_sub_dict = {}
					subid = list(new_buy.keys( ))[0]
					execdict[b'\x07\x00\x00\x00'].update(new_sub)
					# pprint.pprint(new_sub)
					# pprint.pprint(new_buy)
					# pprint.pprint(subid)
					if b"\x02\x00\x00\x00" in blobnew:
						# if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "ValveCDKey\x00" :
						if new_buy[subid][b'\x01\x00\x00\x00'] == b"\x02" :  # PREPURCHASED
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							# receipt_sub_dict [b'\x02\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4, byteorder='little')  + b"\x00" #should be 8 digit hash of key, FIX ME
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][
																		b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
						elif new_buy[subid][b'\x01\x00\x00\x00'] == b"\x01" :  # PAYMENTCARD
							receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
							receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12 :]
							receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
							receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
							receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
							receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
							receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
							receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
							receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
							receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999).to_bytes(3,byteorder='little')).encode('latin-1') + b"\x00"
							receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
							receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
							receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now( ).strftime("%d/%m/%Y").encode('latin-1') + b"\x00"
							receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now( ).strftime("%H:%M:%S").encode('latin-1') + b"\x00"
							receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999).to_bytes(4,byteorder='little')).encode('latin-1') + b"\x00"
							receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
							receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
							receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
							receipt_dict[subid] = receipt_dict_01
					else :
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
						receipt_dict_01[b'\x02\x00\x00\x00'] = {}
						receipt_dict[subid] = receipt_dict_01
					new_buy.clear( )
					execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
					execdict_pprint = pprint.pformat(execdict)
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict_pprint))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys) :
						return {x : d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex(
							"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																									   blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)
			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex(
							"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																									   blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v2 beta
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time( )

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)
				# TODO Get Dynamically from DIR Server?

				if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
					client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"
				else:
					client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # utils.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket),
															 len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest( )

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x1d" or command[0:1] == b"\x1e":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")
				if (os.path.isfile("files/users/" + username_str + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: " + email_str)
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read( )
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists == True:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys) :
				#    return {x: d[x] for x in d if x not in keys}

				# plainblob_fixed = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)
				# pprint.pprint(plainblob)

				#if b'\x01\x00\x00\x00' not in plainblob[b'\x06\x00\x00\x00'][username_str] :
				#    plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = None

				# Assign the new value
				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid
				invalid7 = {b'\x07\x00\x00\x00'}

				# pprint.pprint(plainblob)
				def without_keys(d, keys) :
					return {x : d[x] for x in d if x not in keys}

				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
																   b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
																   b'\x03\x00\x00\x00':b'\x01\x00',
																   b'\x05\x00\x00\x00':b'\x00',
																   b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str.decode( ) + ".py", 'w') as userblobfile :
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob))

				client_socket.send(b"\x00")
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				if os.path.isfile("files/users/" + username_str.decode( ) + ".py") :
					client_socket.send(b"\x00")
				else:
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str.decode( ) + ".py", 'r') as userblobfile :
						userblobstr = userblobfile.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen( )

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					pad_size = dec_blob[-1]
					unser_blob = blobs.blob_unserialize(dec_blob[:-pad_size])

					if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username_str.decode( ) + ".py")) :
							with open("files/users/" + username_str.decode( ) + ".py", 'w') as userblobfile :
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username_str}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username_str}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username_str}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x01")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x00")
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)
				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
										if key == key_str :
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x00")
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				blob = cdr_manipulator.fixblobs( )
				checksum = SHA.new(blob).digest( )

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")
		elif command[1:5] == b"\x00\x00\x00\x05":  # \x04 for 2007+ TEMP SOLUTION FOR DEFAULT SUBSCRIBE ISSUE

			log.debug(f"{clientid}Using 2007 auth protocol")
			client_socket.send(b"\x00" + socket.inet_aton(client_address[0]))
			log.debug((str(socket.inet_aton(client_address[0]))))
			log.debug((str(socket.inet_ntoa(socket.inet_aton(client_address[0])))))

			command = client_socket.recv_withlen( )

			if command[0:1] == b"\x02":  # LOGIN

				usernamelen = struct.unpack(">H", command[1:3])[0]
				log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
				userblob = {}

				username = command[3:3 + usernamelen]

				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
					if blocked == "0001":
						log.info(f"{clientid}Blocked user: {username}")
						client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
						command = client_socket.recv_withlen( )
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						tgt_command = b"\x04"  # BLOCKED
						padding = b"\x00" * 1222
						ticket_full = tgt_command + steamtime + padding
						client_socket.send(ticket_full)
					else:
						personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
						# print(personalsalt)
						client_socket.send(personalsalt)  # NEW SALT PER USER
						command = client_socket.recv_withlen( )
						key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
						# print(binascii.b2a_hex(key))
						IV = command[0:16]
						# print(binascii.b2a_hex(IV))
						encrypted = command[20:36]
						# print(binascii.b2a_hex(encrypted))
						decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
						log.debug(f"{clientid}Authentication package: {decodedmessage}")

						if not decodedmessage.endswith(b"04040404"):
							wrongpass = "1"
							log.info(f"{clientid}Incorrect password entered for: {username}")
						else:
							wrongpass = "0"

						# create login ticket
						execdict = {}
						execdict_new = {}
						execdict_new2 = {}
						with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
							userblobstr = f.read( )
							execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
						secretkey = {b'\x05\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new = without_keys(execdict, secretkey)
						secretkey2 = {b'\x0f\x00\x00\x00'}

						def without_keys(d, keys):
							return {x:d[x] for x in d if x not in keys}

						execdict_new2 = without_keys(execdict_new, secretkey2)
						# print(execdict)
						# print(execdict_new)
						blob = blobs.blob_serialize(execdict)
						if globalvars.steamui_ver < 24:
							blob = blobs.blob_serialize(execdict_new2)
						else:
							blob = blobs.blob_serialize(execdict_new)
						# print(blob)
						bloblen = len(blob)
						log.debug(f"Blob length: {str(bloblen)}")
						innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
						blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
						blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
						blob_signature = encryption.sign_message(innerkey, blob_encrypted)
						blob_encrypted_len = 10 + len(blob_encrypted) + 20
						blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
						currtime = time.time( )
						outerIV = binascii.a2b_hex("92183129534234231231312123123353")
						# steamid = binascii.a2b_hex("ffff" + "ffffffff" + "ffffffff")
						steamUniverse = struct.pack(">H", int(self.config["universe"]))
						steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']
						# servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
						# authport = struct.pack("<L", int(port))
						# TODO grab from directory server
						if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
							bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
						else:
							bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
						# bin_ip = utils.encodeIP(("172.21.0.20", "27039"))
						servers = bin_ip + bin_ip
						times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(
							currtime + (60 * 60 * 24 * 28))
						subheader = innerkey + steamid + servers + times
						subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
						subhead_decr_len = b"\x00\x36"
						subhead_encr_len = b"\x00\x40"
						if globalvars.tgt_version == "1":  # nullData1
							subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
							log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
						elif globalvars.tgt_version == "2":
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # v3 Steam
						else:
							subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
							log.debug(f"{clientid}TGT Version: 2")  # Assume v3 Steam
						clientIP = socket.inet_aton(client_address[0])
						publicIP = clientIP[::-1]
						# subcommand3 = b"\x00\x00\x00\x00"
						data1_len_str = b"\x00\x80"
						# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
						data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
						data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
						data1_full = data1 + (b"\x00" * (data1_len_empty / 2))
						empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
						username_len = len(username)
						# username_len_packed = struct.pack(">H", 50 + username_len)
						accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
						data2 = struct.pack(">L", len(username))
						if globalvars.tgt_version == "1":
							subcommand1 = b"\x00\x01"  # for TGT v1
							subcommand2 = b""  # missing for TGT v1
							empty2_dec_len = b"\x00\x42"
							empty2_enc_len = b"\x00\x50"
							# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
							data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						elif globalvars.tgt_version == "2":
							subcommand1 = b"\x00\x02"  # for TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))
						else:
							subcommand1 = b"\x00\x02"  # assume TGT v2
							subcommand2 = b"\x00\x10"  # steamID+clientIPaddress TGT v2 only
							subcommand2 = subcommand2 + accountId + clientIP
							empty2_dec_len = b"\x00\x52"
							empty2_enc_len = b"\x00\x60"
							# empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
							data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
							data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

						# empty2 = username + empty2_empty[(len(username)):]
						real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
						real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
						# ticket = subheader_encrypted + unknown_part + blob_encrypted
						ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

						ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

						if globalvars.steamui_ver < 24:
							if wrongpass == "1":
								tgt_command = b"\x00"  # Incorrect password
							else:
								tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
						else:
							# tgt_command = b"\x03" #Clock-skew too far out
							if wrongpass == "1":
								tgt_command = b"\x02"  # Incorrect password
							else:
								tgt_command = b"\x00"  # Authenticated # AuthenticateAndRequestTGT command
						steamtime = utils.unixtime_to_steamtime(time.time( ))
						clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
						authenticate = tgt_command + steamtime + clock_skew_tolerance
						writeAccountInformation = struct.pack(">L",
															  len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
						client_socket.send(authenticate + writeAccountInformation)
						# print(bloblen)

				else:
					log.info(f"{clientid}Unknown user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					tgt_command = b"\x01"  # UNKNOWN USER
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
			elif command[0:1] == b"\x10":  # Change password
				# log.info(f"{clientid}Change password")

				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Password change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x11":  # Change question
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

				log.info(f"{clientid}Secret question change requested for: {username}")

				userblob = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				# print(personalsalt)
				client_socket.send(personalsalt)  # NEW SALT PER USER
				blobtext = client_socket.recv_withlen( )
				key = binascii.a2b_hex("10231230211281239191238542314233")
				IV = secrets.token_bytes(16)
				crypted_blob = blobtext[10:]
				if repr(encryption.verify_message(key, crypted_blob)):
					plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
					blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
					blob_len = len(plaintext) - 16 - blob_len
					blob = blobs.blob_unserialize(plaintext[16:-blob_len])
					# print(blob)
					# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
					# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
					if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
						if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
							with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Secret question changed for: {username}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Secret question change failed for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x12":  # Change email
				log.info(f"{clientid}Change email")
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				blob = (decodedmessage[header:header + blob_len])

				new_email_addr = blob[:-blob[-1]] + b"\x00"


				userblob = {}
				execdict_new = {}
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
				new_email = {}
				new_email = {b"\x0b\x00\x00\x00":new_email_addr}
				userblob.update(new_email)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(userblob))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(userblob, secretkey)
				# print(userblob)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = userIV
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len,
																								   0) + blob_encrypted
				ticket = ticket + blob_encrypted
				ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
				client_socket.send(b"\x00" + blob_encrypted + blob_signature)
			elif command[0:1] == b"\x05":  # Subscribe
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				ticket_len = int(ticket_len, 16) * 2
				ticket = ticket_full[2:ticket_len + 2]
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				decodedmessage = binascii.a2b_hex(decodedmessage)
				username_len_new = struct.unpack("<H", decodedmessage[0:2])
				username_len_new = (2 + username_len_new[0]) * 2
				header = username_len_new + 8
				blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
				blob_len = (blob_len[0])
				# Assuming decodedmessage is a byte-string
				blob = decodedmessage[header:header + blob_len]
				# Slice the dec_blob to remove padding and unserialize
				blobnew = blobs.blob_unserialize(decodedmessage[:-blob[-1]])



				log.info(f"{clientid}Subscribe to package " + str(struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					execdict = {}
				execdict_new = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
				execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				steamtime = utils.unixtime_to_steamtime(time.time( ))
				new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00':steamtime,
														 b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
														 b'\x03\x00\x00\x00':b'\x00\x00', b'\x05\x00\x00\x00':b'\x00',
														 b'\x06\x00\x00\x00':b'\x1f\x00'}}
				if b"\x02\x00\x00\x00" in blobnew:
					new_buy = {blobnew[b'\x01\x00\x00\x00']:blobnew[b'\x02\x00\x00\x00']}
				else:
					log.debug(f"{clientid}Subscribing to default subscription")
				new_buy = {blobnew[b'\x01\x00\x00\x00']:{}}  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				receipt_dict = {}
				receipt_dict_01 = {}
				receipt_sub_dict = {}
				subid = list(new_buy.keys( ))[0]
				execdict[b'\x07\x00\x00\x00'].update(new_sub)
				# pprint.pprint(new_sub)
				# pprint.pprint(new_buy)
				# pprint.pprint(subid)
				if b"\x02\x00\x00\x00" in blobnew:
				# if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == b"ValveCDKey\x00" :
					if new_buy[subid][b'\x01\x00\x00\x00'] == b"\x02":  # PREPURCHASED
						receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
						# receipt_sub_dict[b'\x02\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4, byteorder='little') + b"\x00" #should be 8 digit hash of key, FIX ME
						receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][
																	b'\x02\x00\x00\x00'] + b"\x00"  # saving key for now for verification
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
						receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
						receipt_dict[subid] = receipt_dict_01
					elif new_buy[subid][b'\x01\x00\x00\x00'] == b"\x01":  # PAYMENTCARD
						receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
						receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
						receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
						receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
						receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
						receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
						receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
						receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
						receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
						receipt_sub_dict[b'\x0d\x00\x00\x00'] = random.randint(111111, 999999).to_bytes(3, byteorder='little') + b"\x00"
						receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
						receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
						receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now( ).strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
						receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now( ).strftime("%H:%M:%S").encode("latin-1") + b"\x00"
						receipt_sub_dict[b'\x12\x00\x00\x00'] = random.randint(11111111, 99999999).to_bytes(4, byteorder='little') + b"\x00"
						receipt_sub_dict[b'\x13\x00\x00\x00'] = b"\x00\x00\x00\x00"
						receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
						receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
						receipt_dict[subid] = receipt_dict_01
				else:
					receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07"  # SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
					receipt_dict_01[b'\x02\x00\x00\x00'] = {}
					receipt_dict[subid] = receipt_dict_01
				new_buy.clear( )
				execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				# print(execdict)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len,
																								   0) + blob_encrypted + blob_signature
				client_socket.send(b"\x00" + blob_encrypted)

			elif command[0:1] == b"\x09":  # Ticket Login
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Ticket login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------
				if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
					# client_socket.send(b"\x00")
					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
									execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
									execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
					secretkey = {b'\x05\x00\x00\x00'}


					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}


					execdict_new = without_keys(execdict, secretkey)
					# print(execdict)
					# print(execdict_new)
					blob = blobs.blob_serialize(execdict_new)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature
					client_socket.send(b"\x00" + blob_encrypted)

					execdict = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					for sub_dict in execdict:
						if sub_dict == b"\x07\x00\x00\x00":
							for sub_sub_dict in execdict[sub_dict]:
								if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
									# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
									execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
									# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
					with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
						g.write("user_registry = " + str(execdict))
			elif command[0:1] == b"\x04":  # Logout
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}User {username} logged out")
			elif command[0:1] == b"\x0a":  # Request content ticket Steam v1
				ticket_full = binascii.b2a_hex(command)
				command = ticket_full[0:2]
				ticket_len = ticket_full[2:6]
				tgt_ver = ticket_full[6:10]
				data1_len = ticket_full[10:14]
				data1_len = int(data1_len, 16) * 2
				userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
				username_len = ticket_full[314:318]
				username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
				log.info(f"{clientid}Content login for: {username}")
				ticket_len = int(ticket_len, 16) * 2
				postticketdata = ticket_full[2 + ticket_len + 4:]
				key = binascii.a2b_hex("10231230211281239191238542314233")
				iv = binascii.a2b_hex(postticketdata[0:32])
				encdata_len = int(postticketdata[36:40], 16) * 2
				encdata = postticketdata[40:40 + encdata_len]
				decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
				# ------------------------------------------------------------------

				# Incompatible ContentTicket VersionNum
				# u16SizeOfPlaintextClientReadableContentTicket
				# Bad u16SizeOfAESEncryptedClientReadableContentTicket

				# u16SizeOfServerReadableContentTicket

				currtime = time.time( )

				client_ticket = b"\x69" * 0x10  # key used for MAC signature
				client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
				client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
				client_ticket += os.urandom(4)  # struct.pack("<I", 1)
				client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)
				client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

				server_ticket = b"\x55" * 0x80

				innerIV = secrets.token_bytes(16)

				client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

				ticket = b"\x00\x02" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted
				# ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted #FOR BETA 2003
				ticket += struct.pack(">H", len(server_ticket)) + server_ticket

				# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
				ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest( )

				client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
			elif command[0:1] == b"\x1d" or command[0:1] == b"\x1e":  # Check username - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check username exists: {username_str}")
				# TODO SEND SUGGESTIONS PACKET
				if (os.path.isfile("files/users/" + username_str + ".py")):
					log.warning(f"{clientid}New user: username already exists")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: username not found")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x22":  # Check email - new user
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)
				email = plainblob[b'\x01\x00\x00\x00']
				email_str = email.rstrip(b'\x00')
				# print(len(username_str))
				log.info(f"{clientid}New user: check email exists: " + email_str)
				email_exists = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read( )
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_exists = True
							break
				if email_exists == True:
					log.warning(f"{clientid}New user: email already in use")
					client_socket.send(b"\xff")  # not working
				else:
					log.info(f"{clientid}New user: email ok to use")
					client_socket.send(b"\x00")
			elif command[0:1] == b"\x01":  # New user
				log.info(f"{clientid}New user: Create user")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				plainblob = blobs.blob_unserialize(plaintext)
				# print(plainblob)

				username = plainblob[b'\x01\x00\x00\x00']
				username_str = username.rstrip(b'\x00')

				# invalid6 = {b'\x06\x00\x00\x00'}
				# def without_keys(d, keys) :
				#    return {x: d[x] for x in d if x not in keys}

				# plainblob_fixed = without_keys(plainblob, invalid6)

				# dict6 = {}
				# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

				# plainblob_fixed.update(dict6)

				newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
				plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid

				invalid7 = {b'\x07\x00\x00\x00'}


				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}


				plainblob_fixed = without_keys(plainblob, invalid7)

				dict7 = {}
				dict7 = {b'\x07\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00',
																   b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
																   b'\x03\x00\x00\x00':b'\x01\x00', b'\x05\x00\x00\x00':b'\x00',
																   b'\x06\x00\x00\x00':b'\x1f\x00'}}}

				plainblob_fixed.update(dict7)

				dictf = {}
				dictf = {b'\x0f\x00\x00\x00':{b'\x00\x00\x00\x00':{b'\x01\x00\x00\x00':b'\x07', b'\x02\x00\x00\x00':{}}}}

				plainblob_fixed.update(dictf)

				plainblob_fixed = pprint.pformat(plainblob_fixed)

				with open("files/users/" + username_str + ".py", 'w') as userblobfile:
					userblobfile.write("user_registry = ")
					userblobfile.write(str(plainblob_fixed))

				client_socket.send(b"\x00")
			elif command[0:1] == b"\x0e":  # Check username - password reset
				log.info(f"{clientid}Password reset: check username exists")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				if os.path.isfile("files/users/" + username_str + ".py"):
					client_socket.send(b"\x00")
				else:
					client_socket.send(b"\x01")
			elif command[0:1] == b"\x0f":  # Reset password
				log.info(f"{clientid}Password reset by client")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					usernamechk = blobdict[b'\x01\x00\x00\x00']
					username_str = usernamechk.rstrip(b'\x00')
					with open("files/users/" + username_str + ".py", 'r') as userblobfile:
						userblobstr = userblobfile.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					# print(userblob)
					questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
					# print(questionsalt)
					client_socket.send(questionsalt)  # USER'S QUESTION SALT
					reply2 = client_socket.recv_withlen( )

					header = reply2[0:2]
					enc_len = reply2[2:6]
					zeros = reply2[6:10]
					blob_len = reply2[10:14]
					innerIV = reply2[14:30]
					enc_blob = reply2[30:-20]
					sig = reply2[-20:]
					dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
					pad_size = dec_blob[-1]
					unser_blob = blobs.blob_unserialize(dec_blob[:-pad_size])


					if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
						userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
						if (os.path.isfile("files/users/" + username_str + ".py")):
							with open("files/users/" + username_str + ".py", 'w') as userblobfile:
								userblobfile.write("user_registry = ")
								userblobfile.write(str(userblob))
							log.info(f"{clientid}Password changed for: {username_str}")
							client_socket.send(b"\x00")
						else:
							log.warning(f"{clientid}SADB file error for: {username_str}")
							client_socket.send(b"\x01")
					else:
						log.warning(f"{clientid}Password change failed for: {username_str}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change message could not be decrypted")
					client_socket.send(b"\x01")

				reply = {}
				reply2 = {}
			elif command[0:1] == b"\x20":  # Check email - password reset
				log.info(f"{clientid}Password reset by email")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					emailchk = blobdict[b'\x01\x00\x00\x00']
					email_str = emailchk.rstrip(b'\x00')
					email_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							email_addr = userblob[b'\x0b\x00\x00\x00']
							if email_addr.rstrip(b'\x00') == email_str:
								email_found = True
								break
					if email_found:
						client_socket.send(b"\x00")
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x21":  # Check key - password reset
				log.info(f"{clientid}Password reset by CD key")
				self.send_mainkey(client_socket)

				reply = client_socket.recv_withlen( )

				RSAdata = reply[2:130]
				datalength = struct.unpack(">L", reply[130:134])[0]
				cryptedblob_signature = reply[134:136]
				cryptedblob_length = reply[136:140]
				cryptedblob_slack = reply[140:144]
				cryptedblob = reply[144:]

				key = encryption.get_aes_key(RSAdata, encryption.network_key)
				log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
				if repr(encryption.verify_message(key, cryptedblob)):
					plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
					IV = cryptedblob[4:20]
					ciphertext = cryptedblob[20:-20]
					plaintext = encryption.aes_decrypt(key, IV, ciphertext)
					plaintext = plaintext[0:plaintext_length]
					# print(plaintext)
					blobdict = blobs.blob_unserialize(plaintext)
					# print(blobdict)
					keychk = blobdict[b'\x01\x00\x00\x00']
					key_str = keychk.rstrip(b'\x00')
					key_found = False
					for file in os.listdir("files/users/"):
						if file.endswith("py"):
							with open("files/users/" + file, 'r') as f:
								userblobstr = f.read( )
								userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
							for sub in userblob[b'\x0f\x00\x00\x00']:
								for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
									if prodcdkey == b"\x06":
										key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
										if key == key_str:
											key_found = True
											break
					if key_found:
						client_socket.send(b"\x00")
					else:
						client_socket.send(b"\x01")
			elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
				if os.path.isfile("files/cache/secondblob.bin"):
					with open("files/cache/secondblob.bin", "rb") as f:
						blob = f.read( )
				elif os.path.isfile("files/2ndcdr.py") or os.path.isfile("files/secondblob.py"):
					if os.path.isfile("files/2ndcdr.orig"):
						# shutil.copy2("files/2ndcdr.py","files/2ndcdr.orig")
						os.remove("files/2ndcdr.py")
						shutil.copy2("files/2ndcdr.orig", "files/secondblob.py")
						os.remove("files/2ndcdr.orig")
					if os.path.isfile("files/2ndcdr.py"):
						shutil.copy2("files/2ndcdr.py", "files/secondblob.py")
						os.remove("files/2ndcdr.py")
					with open("files/secondblob.py", "r") as g:
						file = g.read( )

					for (search, replace, info) in globalvars.replacestringsCDR:
						fulllength = len(search)
						newlength = len(replace)
						missinglength = fulllength - newlength
						if missinglength < 0:
							print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
						else:
							fileold = file
							file = file.replace(search, replace)
							if (search in fileold) and (replace in file):
								print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")
					# h = open("files/2ndcdr.py", "w")
					# h.write(file)
					# h.close()

					execdict = {}
					execdict_temp_01 = {}
					execdict_temp_02 = {}
					# execfile("files/2ndcdr.py", execdict)
					exec(file, execdict)

					for file in os.walk("files/custom"):
						for pyblobfile in file[2]:
							if (pyblobfile.endswith(".py") or pyblobfile.endswith(
									".bin")) and not pyblobfile == "2ndcdr.py" and not pyblobfile == "1stcdr.py" and not pyblobfile.startswith(
									"firstblob") and not pyblobfile.startswith("secondblob"):
								# if os.path.isfile("files/extrablob.py") :
								log.info(f"{clientid}Found extra blob: {pyblobfile}")
								execdict_update = {}

								if pyblobfile.endswith(".bin"):
									f = open("files/custom/" + pyblobfile, "rb")
									blob = f.read( )
									f.close( )

									if blob[0:2] == b"\x01\x43":
										blob = zlib.decompress(blob[20:])
									blob2 = blobs.blob_unserialize(blob)
									blob3 = blobs.blob_dump(blob2)
									execdict_update = b"blob = " + blob3

									for (search, replace, info) in globalvars.replacestringsCDR:
										print("Fixing CDR 16")
										fulllength = len(search)
										newlength = len(replace)
										missinglength = fulllength - newlength
										if missinglength < 0:
											print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
										else:
											execdict_update = execdict_update.replace(search, replace)
											print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

								elif pyblobfile.endswith(".py"):
									with open("files/custom/" + pyblobfile, 'r') as m:
										userblobstr_upd = m.read( )

									for (search, replace, info) in globalvars.replacestringsCDR:
										print("Fixing CDR 17")
										fulllength = len(search)
										newlength = len(replace)
										missinglength = fulllength - newlength
										if missinglength < 0:
											print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
										else:
											userblobstr_upd = userblobstr_upd.replace(search, replace)
											print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

									execdict_update = ast.literal_eval(userblobstr_upd[7:len(userblobstr_upd)])

								for k in execdict_update:
									for j in execdict[b"blob"]:
										if j == k:
											execdict[b"blob"][j].update(execdict_update[k])
										else:
											if k == b"\x01\x00\x00\x00":
												execdict_temp_01.update(execdict_update[k])
											elif k == b"\x02\x00\x00\x00":
												execdict_temp_02.update(execdict_update[k])

								for k, v in execdict_temp_01.items( ):
									execdict[b"blob"].pop(k, v)

								for k, v in execdict_temp_02.items( ):
									execdict[b"blob"].pop(k, v)

					blob = blobs.blob_serialize(execdict[b"blob"])

					if blob[0:2] == b"\x01\x43":
						blob = zlib.decompress(blob[20:])

					start_search = 0
					while True:
						found = blob.find(b"\x30\x81\x9d\x30\x0d\x06\x09\x2a", start_search)
						if found < 0:
							break

						# TINserver's Net Key
						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"
						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
						foundstring = blob[found:found + 160]
						blob = blob.replace(foundstring, encryption.BERstring)
						start_search = found + 160

					compressed_blob = zlib.compress(blob, 9)
					blob = b"\x01\x43" + struct.pack("<QQH", len(compressed_blob) + 20, len(blob), 9) + compressed_blob

					# cache_option = self.config["use_cached_blob"]
					# if cache_option == "true" :
					f = open("files/cache/secondblob.bin", "wb")
					f.write(blob)
					f.close( )

				else:
					if os.path.isfile("files/secondblob.orig"):
						os.remove("files/secondblob.bin")
						shutil.copy2("files/secondblob.orig", "files/secondblob.bin")
						os.remove("files/secondblob.orig")
					with open("files/secondblob.bin", "rb") as g:
						blob = g.read( )

					if blob[0:2] == b"\x01\x43":
						blob = zlib.decompress(blob[20:])
					blob2 = blobs.blob_unserialize(blob)
					blob3 = blobs.blob_dump(blob2)
					file = b"blob = " + blob3

					for (search, replace, info) in globalvars.replacestringsCDR:
						print("Fixing CDR 18")
						fulllength = len(search)
						newlength = len(replace)
						missinglength = fulllength - newlength
						if missinglength < 0:
							print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
						else:
							file = file.replace(search, replace)
							print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

					execdict = {}
					execdict_temp_01 = {}
					execdict_temp_02 = {}
					exec(file, execdict)

					for file in os.walk("files/custom"):
						for pyblobfile in file[2]:
							if (pyblobfile.endswith(".py") or pyblobfile.endswith(
									".bin")) and not pyblobfile == "2ndcdr.py" and not pyblobfile == "1stcdr.py" and not pyblobfile.startswith(
									"firstblob") and not pyblobfile.startswith("secondblob"):
								# if os.path.isfile("files/extrablob.py") :
								log.info(f"{clientid}Found extra blob: " + pyblobfile)
								execdict_update = {}

								if pyblobfile.endswith(".bin"):
									f = open("files/custom/" + pyblobfile, "rb")
									blob = f.read( )
									f.close( )

									if blob[0:2] == b"\x01\x43":
										blob = zlib.decompress(blob[20:])
									blob2 = blobs.blob_unserialize(blob)
									blob3 = blobs.blob_dump(blob2)
									execdict_update = "blob = " + blob3

									for (search, replace, info) in globalvars.replacestringsCDR:
										print("Fixing CDR 19")
										fulllength = len(search)
										newlength = len(replace)
										missinglength = fulllength - newlength
										if missinglength < 0:
											print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
										else:
											execdict_update = execdict_update.replace(search, replace)
											print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

								elif pyblobfile.endswith(".py"):
									with open("files/custom/" + pyblobfile, 'r') as m:
										userblobstr_upd = m.read( )

									for (search, replace, info) in globalvars.replacestringsCDR:
										print("Fixing CDR 20")
										fulllength = len(search)
										newlength = len(replace)
										missinglength = fulllength - newlength
										if missinglength < 0:
											print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
										else:
											userblobstr_upd = userblobstr_upd.replace(search, replace)
											print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

									execdict_update = ast.literal_eval(userblobstr_upd[7:len(userblobstr_upd)])

								for k in execdict_update:
									for j in execdict[b"blob"]:
										if j == k:
											execdict[b"blob"][j].update(execdict_update[k])
										else:
											if k == b"\x01\x00\x00\x00":
												execdict_temp_01.update(execdict_update[k])
											elif k == b"\x02\x00\x00\x00":
												execdict_temp_02.update(execdict_update[k])

								for k, v in execdict_temp_01.items( ):
									execdict[b"blob"].pop(k, v)

								for k, v in execdict_temp_02.items( ):
									execdict[b"blob"].pop(k, v)

					blob = blobs.blob_serialize(execdict[b"blob"])

					# h = open("files/secondblob.bin", "wb")
					# h.write(blob)
					# h.close()

					# g = open("files/secondblob.bin", "rb")
					# blob = g.read()
					# g.close()

					if blob[0:2] == b"\x01\x43":
						blob = zlib.decompress(blob[20:])

					start_search = 0
					while True:
						found = blob.find(b"\x30\x81\x9d\x30\x0d\x06\x09\x2a", start_search)
						if found < 0:
							break

						# TINserver's Net Key
						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"

						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
						# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
						foundstring = blob[found:found + 160]
						blob = blob.replace(foundstring, encryption.BERstring)
						start_search = found + 160

					compressed_blob = zlib.compress(blob, 9)
					blob = b"\x01\x43" + struct.pack("<QQH", len(compressed_blob) + 20, len(blob), 9) + compressed_blob

					# cache_option = self.config["use_cached_blob"]
					# if cache_option == "true" :
					f = open("files/cache/secondblob.bin", "wb")
					f.write(blob)
					f.close( )

				checksum = SHA.new(blob).digest( )

				if checksum == command[1:]:
					log.info(f"{clientid}Client has matching checksum for secondblob")
					log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

					client_socket.send(b"\x00\x00\x00\x00")

				else:
					log.info(f"{clientid}Client didn't match our checksum for secondblob")
					log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

					client_socket.send_withlen(blob, True)  # false for not showing in log
			else:
				log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
				client_socket.send(b"\x01")

		else:
			data = client_socket.recv(65535)
			log.warning(f"{clientid}Invalid command: {binascii.b2a_hex(command[1:5])}")
			log.warning(f"{clientid}Extra data: {binascii.b2a_hex(data)}")

		client_socket.close( )
		log.info(f"{clientid}Disconnected from Auth Server")



	def send_mainkey(self, client_socket):
		mainkey = encryption.get_mainkey_reply()
		client_socket.send(mainkey)


	def process_beta2_packets(self, clientid, client_socket, client_address, log):
		log.debug(f"{clientid}Using 2003 beta auth protocol")
		client_socket.send(b"\x00" + socket.inet_aton(client_address[0]))
		log.debug((str(socket.inet_aton(client_address[0]))))
		log.debug((str(socket.inet_ntoa(socket.inet_aton(client_address[0])))))
		command = client_socket.recv_withlen( )
		if command[0:1] == b"\x02":  # LOGIN

			usernamelen = struct.unpack(">H", command[1:3])[0]
			log.debug(f"{clientid}Main login command: {binascii.b2a_hex(command[0:1])}")
			userblob = {}

			username = command[3:3 + usernamelen]

			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				# print(userblob)
				blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
				if blocked == b"0001":
					log.info(f"{clientid}Blocked user: {username}")
					client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
					command = client_socket.recv_withlen( )
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					tgt_command = b"\x04"  # BLOCKED
					padding = b"\x00" * 1222
					ticket_full = tgt_command + steamtime + padding
					client_socket.send(ticket_full)
				else:
					personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
					# print(personalsalt)
					client_socket.send(personalsalt)  # NEW SALT PER USER
					command = client_socket.recv_withlen( )
					key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][
						  0:16]  # password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
					# print(binascii.b2a_hex(key))
					IV = command[0:16]
					# print(binascii.b2a_hex(IV))
					encrypted = command[20:36]
					# print(binascii.b2a_hex(encrypted))
					decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, IV, encrypted))
					log.debug(f"{clientid}Authentication package: {decodedmessage}")

					if not decodedmessage.endswith(b"04040404"):
						wrongpass = "1"
						log.info(f"{clientid}Incorrect password entered for: {username}")
					else:
						wrongpass = "0"

					# create login ticket
					execdict = {}
					execdict_new = {}
					with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
						userblobstr = f.read( )
						execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
					secretkey = {b'\x05\x00\x00\x00'}

					def without_keys(d, keys):
						return {x:d[x] for x in d if x not in keys}

					execdict_new = without_keys(execdict, secretkey)
					secretkey2 = {b'\x0f\x00\x00\x00'}

					def without_keys(d, keys2):
						return {x:d[x] for x in d if x not in keys2}

					execdict_new2 = without_keys(execdict_new, secretkey2)
					# print(execdict)
					# print(execdict_new)
					##blob = steam.blob_serialize(execdict)
					blob = blobs.blob_serialize(execdict_new2)
					# print(blob)
					bloblen = len(blob)
					log.debug(f"Blob length: {str(bloblen)}")
					innerkey = binascii.a2b_hex(
							"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					innerIV = binascii.a2b_hex(
							"12899c8312213a123321321321543344")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
					blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
					blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
					blob_signature = encryption.sign_message(innerkey, blob_encrypted)
					blob_encrypted_len = 10 + len(blob_encrypted) + 20
					blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																									   blob_encrypted_len,
																									   0) + blob_encrypted + blob_signature
					currtime = time.time( )
					outerIV = binascii.a2b_hex("92183129534234231231312123123353")
					steamUniverse = struct.pack(">H", int(self.config["universe"]))
					steamid = steamUniverse + userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00']
					if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
						bin_ip = utils.encodeIP((self.config["server_ip"], self.config["validation_port"]))
					else:
						bin_ip = utils.encodeIP((self.config["public_ip"], self.config["validation_port"]))
					servers = bin_ip + bin_ip
					times = utils.unixtime_to_steamtime(currtime) + utils.unixtime_to_steamtime(
							currtime + (60 * 60 * 24 * 28))
					subheader = innerkey + steamid + servers + times
					subheader_encrypted = encryption.aes_encrypt(key, outerIV, subheader)
					subhead_decr_len = b"\x00\x36"
					subhead_encr_len = b"\x00\x40"
					subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted  # TTicket_SubHeader (EncrData)
					log.debug(f"{clientid}TGT Version: 1")  # v1/v2 Steam
					clientIP = socket.inet_aton(client_address[0])
					publicIP = clientIP[::-1]
					# subcommand3 = b"\x00\x00\x00\x00"
					data1_len_str = b"\x00\x80"
					# empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
					data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
					data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
					data1_full = data1 + (b"\x00" * (data1_len_empty // 2))
					empty3 = (b"\x00" * 0x80)  # unknown encrypted - RSA sig?
					username_len = len(username)
					# username_len_packed = struct.pack(">H", 50 + username_len)
					accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]  # SteamID
					data2 = struct.pack(">L", len(username))
					subcommand1 = b"\x00\x01"  # for TGT v1
					subcommand2 = b""  # missing for TGT v1
					empty2_dec_len = b"\x00\x42"
					empty2_enc_len = b"\x00\x50"
					# empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
					data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
					data2_full = data2 + (b"\x00" * (data2_len_empty // 2))

					# empty2 = username + empty2_empty[(len(username)):]
					real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
					real_ticket_len = struct.pack(">H", len(real_ticket))  # TicketLen
					# ticket = subheader_encrypted + unknown_part + blob_encrypted
					ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted

					ticket_signed = ticket + encryption.sign_message(innerkey, ticket)

					if wrongpass == "1":
						tgt_command = b"\x00"  # Incorrect password
					else:
						tgt_command = b"\x01"  # Authenticated # AuthenticateAndRequestTGT command
					steamtime = utils.unixtime_to_steamtime(time.time( ))
					clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
					authenticate = tgt_command + steamtime + clock_skew_tolerance
					writeAccountInformation = struct.pack(">L",
														  len(ticket_signed)) + ticket_signed  # FULL TICKET (steamticket.bin)
					client_socket.send(authenticate + writeAccountInformation)
					# print(bloblen)

			else:
				log.info(f"{clientid}Unknown user: {username}")
				client_socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
				steamtime = utils.unixtime_to_steamtime(time.time( ))
				tgt_command = b"\x00"  # UNKNOWN USER
				padding = b"\x00" * 1222
				ticket_full = tgt_command + steamtime + padding
				client_socket.send(ticket_full)
		elif command[0:1] == b"\x10":  # Change password
			# log.info(f"{clientid}Change password")

			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

			log.info(f"{clientid}Password change requested for: {username}")

			userblob = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			# print(personalsalt)
			client_socket.send(personalsalt)  # NEW SALT PER USER
			blobtext = client_socket.recv_withlen( )
			key = binascii.a2b_hex("10231230211281239191238542314233")
			IV = secrets.token_bytes(16)
			crypted_blob = blobtext[10:]
			if repr(encryption.verify_message(key, crypted_blob)):
				plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
				blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
				blob_len = len(plaintext) - 16 - blob_len
				blob = blobs.blob_unserialize(plaintext[16:-blob_len])
				# print(blob)
				# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
				# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
				if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
					userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
					if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
						with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
							userblobfile.write("user_registry = ")
							userblobfile.write(str(userblob))
						log.info(f"{clientid}Password changed for: {username}")
						client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}SADB file error for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username}")
					client_socket.send(b"\x01")
			else:
				log.warning(f"{clientid}Password change failed for: {username}")
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x11":  # Change question
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])

			log.info(f"{clientid}Secret question change requested for: {username}")

			userblob = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			# print(personalsalt)
			client_socket.send(personalsalt)  # NEW SALT PER USER
			blobtext = client_socket.recv_withlen( )
			key = binascii.a2b_hex("10231230211281239191238542314233")
			IV = secrets.token_bytes(16)
			crypted_blob = blobtext[10:]
			if repr(encryption.verify_message(key, crypted_blob)):
				plaintext = encryption.aes_decrypt(key, IV, crypted_blob[4:-4])
				blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
				blob_len = len(plaintext) - 16 - blob_len
				blob = blobs.blob_unserialize(plaintext[16:-blob_len])
				# print(blob)
				# print(binascii.b2a_hex(blob[b'\x01\x00\x00\x00']))
				# print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
				if blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']:
					userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b'\x02\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b'\x04\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b'\x03\x00\x00\x00']
					if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
						with open("files/users/" + username.decode('latin-1') + ".py", 'w') as userblobfile:
							userblobfile.write("user_registry = ")
							userblobfile.write(str(userblob))
						log.info(f"{clientid}Secret question changed for: {username}")
						client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}SADB file error for: {username}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Secret question change failed for: {username}")
					client_socket.send(b"\x01")
			else:
				log.warning(f"{clientid}Secret question change failed for: {username}")
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x12":  # Change email
			log.info(f"{clientid}Change email")
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
			blob_len = (blob_len[0])
			blob = (decodedmessage[header:header + blob_len])
			new_email_addr = blob[:-blob[-1]] + b"\x00"
			userblob = {}
			execdict_new = {}
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
			personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
			new_email = {}
			new_email = {b"\x0b\x00\x00\x00":new_email_addr}
			userblob.update(new_email)
			with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
				g.write("user_registry = " + str(userblob))
			secretkey = {b'\x05\x00\x00\x00'}

			def without_keys(d, keys):
				return {x:d[x] for x in d if x not in keys}

			execdict_new = without_keys(userblob, secretkey)
			# print(userblob)
			# print(execdict_new)
			blob = blobs.blob_serialize(execdict_new)
			# print(blob)
			bloblen = len(blob)
			log.debug(f"Blob length: {str(bloblen)}")
			innerkey = binascii.a2b_hex("10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
			# innerIV  = secrets.token_bytes(16) #ONLY FOR BLOB ENCRYPTION USING AES-CBC
			innerIV = userIV
			blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
			blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
			blob_signature = encryption.sign_message(innerkey, blob_encrypted)
			blob_encrypted_len = 10 + len(blob_encrypted) + 20
			blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len,
																							   0) + blob_encrypted
			ticket = ticket + blob_encrypted
			ticket_signed = ticket + encryption.sign_message(innerkey, ticket)
			client_socket.send(b"\x00" + blob_encrypted + blob_signature)
		elif command[0:1] == b"\x05":  # Subscribe
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
			blob_len = (blob_len[0])
			blob = (decodedmessage[header:header + blob_len])
			padding_byte = blob[-1:]
			padding_int = struct.unpack(">B", padding_byte)
			blobnew = blobs.blob_unserialize(decodedmessage[header:header + blob_len])
			log.info(f"{clientid}Subscribe to package " + str(struct.unpack("<L", blobnew[b'\x01\x00\x00\x00'])[0]))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				execdict = {}
				execdict_new = {}
				execdict_new2 = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				steamtime = utils.unixtime_to_steamtime(time.time( ))
				new_sub = {blobnew[b'\x01\x00\x00\x00']:{b'\x01\x00\x00\x00':steamtime,
														 b'\x02\x00\x00\x00':b'\x00\x00\x00\x00\x00\x00\x00\x00',
														 b'\x03\x00\x00\x00':b'\x00\x00', b'\x05\x00\x00\x00':b'\x00',
														 b'\x06\x00\x00\x00':b'\x1f\x00'}}
				# if b"\x02\x00\x00\x00" in blobnew :
				#    new_buy = {blobnew[b'\x01\x00\x00\x00']: blobnew[b'\x02\x00\x00\x00']}
				# else :
				#    new_buy = {blobnew[b'\x01\x00\x00\x00']: {}} #SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				# receipt_dict = {}
				# receipt_dict_01 = {}
				# receipt_sub_dict = {}
				# subid = new_buy.keys()[0]
				execdict[b'\x07\x00\x00\x00'].update(new_sub)
				# pprint.pprint(new_sub)
				# pprint.pprint(new_buy)
				# pprint.pprint(subid)
				# if b"\x02\x00\x00\x00" in blobnew :
				#    if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "ValveCDKey\x00" :
				#        receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
				#        #receipt_sub_dict[b'\x02\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00" #should be 8 digit hash of key, FIX ME
				#        receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'] + b"\x00" #saving key for now for verification
				#        receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x06"
				#        receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
				#        receipt_dict[subid] = receipt_dict_01
				#    else :
				#        receipt_sub_dict[b'\x01\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00']
				#        receipt_sub_dict[b'\x02\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][12:]
				#        receipt_sub_dict[b'\x03\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x03\x00\x00\x00']
				#        receipt_sub_dict[b'\x07\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x07\x00\x00\x00']
				#        receipt_sub_dict[b'\x08\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x08\x00\x00\x00']
				#        receipt_sub_dict[b'\x09\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x09\x00\x00\x00']
				#        receipt_sub_dict[b'\x0a\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0a\x00\x00\x00']
				#        receipt_sub_dict[b'\x0b\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0b\x00\x00\x00']
				#        receipt_sub_dict[b'\x0c\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x0c\x00\x00\x00']
				#        receipt_sub_dict[b'\x0d\x00\x00\x00'] = str(random.randint(111111, 999999)) + b"\x00"
				#        receipt_sub_dict[b'\x0e\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x14\x00\x00\x00']
				#        receipt_sub_dict[b'\x0f\x00\x00\x00'] = new_buy[subid][b'\x02\x00\x00\x00'][b'\x15\x00\x00\x00']
				#        receipt_sub_dict[b'\x10\x00\x00\x00'] = datetime.datetime.now().strftime("%d/%m/%Y").encode("latin-1") + b"\x00"
				#        receipt_sub_dict[b'\x11\x00\x00\x00'] = datetime.datetime.now().strftime("%H:%M:%S").encode("latin-1") + b"\x00"
				#        receipt_sub_dict[b'\x12\x00\x00\x00'] = str(random.randint(11111111, 99999999)) + b"\x00"
				#        receipt_sub_dict[b'\x13\x00\x00\x00'] = "\x00\x00\x00\x00"
				#        receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x05"
				#        receipt_dict_01[b'\x02\x00\x00\x00'] = receipt_sub_dict
				#        receipt_dict[subid] = receipt_dict_01
				# else :
				#    receipt_dict_01[b'\x01\x00\x00\x00'] = b"\x07" #SUBSCRIBE TO DEFAULT SUBSCRIPTION 0
				#    receipt_dict_01[b'\x02\x00\x00\x00'] = {}
				#    receipt_dict[subid] = receipt_dict_01
				# new_buy.clear()
				# execdict[b'\x0f\x00\x00\x00'].update(receipt_dict)
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}  # NEEDS TO BE LEFT IN FOR 2007 BUT NOT FOR 2003

				def without_keys(d, keys2):
					return {x:d[x] for x in d if x not in keys2}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(execdict)
				# print(execdict_new)
				# blob = blobs.blob_serialize(execdict)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex(
						"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																								   blob_encrypted_len,
																								   0) + blob_encrypted + blob_signature
				# client_socket.send(b"\x01" + blob_encrypted)
				client_socket.send(blob_encrypted)
		elif command[0:1] == b"\x06":  # Unsubscribe
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			ticket_len = int(ticket_len, 16) * 2
			ticket = ticket_full[2:ticket_len + 2]
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			decodedmessage = binascii.a2b_hex(decodedmessage)
			username_len_new = struct.unpack("<H", decodedmessage[0:2])
			username_len_new = (2 + username_len_new[0]) * 2
			header = username_len_new + 8
			padding_byte = decodedmessage[-1:]
			padding_int, = struct.unpack(">B", padding_byte)
			sub_id, = struct.unpack("<L", decodedmessage[header:-padding_int])
			log.info(f"{clientid}Unsubscribe from package " + str(sub_id))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				execdict = {}
				execdict_new = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				del execdict[b'\x07\x00\x00\x00'][struct.pack("<L", sub_id)]
				execdict_pprint = pprint.pformat(execdict)
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict_pprint))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}

				def without_keys(d, keys2):
					return {x:d[x] for x in d if x not in keys2}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				blob = blobs.blob_serialize(execdict_new2)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex(
						"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																								   blob_encrypted_len,
																								   0) + blob_encrypted + blob_signature
				client_socket.send(blob_encrypted)
		elif command[0:1] == b"\x09":  # Ticket Login/refresh games list
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}Ticket login for: {username}")
			ticket_len = int(ticket_len, 16) * 2
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			# ------------------------------------------------------------------
			if (os.path.isfile("files/users/" + username.decode('latin-1') + ".py")):
				# client_socket.send(b"\x00")
				# create login ticket
				execdict = {}
				execdict_new = {}
				execdict_new2 = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				for sub_dict in execdict:
					if sub_dict == b"\x07\x00\x00\x00":
						for sub_sub_dict in execdict[sub_dict]:
							if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x00\x00":
								execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
								execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x01"
								execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict))
				secretkey = {b'\x05\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new = without_keys(execdict, secretkey)
				secretkey2 = {b'\x0f\x00\x00\x00'}

				def without_keys(d, keys):
					return {x:d[x] for x in d if x not in keys}

				execdict_new2 = without_keys(execdict_new, secretkey2)
				# print(execdict)
				# print(execdict_new)
				blob = blobs.blob_serialize(execdict_new2)
				# print(blob)
				bloblen = len(blob)
				log.debug(f"Blob length: {str(bloblen)}")
				innerkey = binascii.a2b_hex(
						"10231230211281239191238542314233")  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				innerIV = secrets.token_bytes(16)  # ONLY FOR BLOB ENCRYPTION USING AES-CBC
				blob_encrypted = encryption.aes_encrypt(innerkey, innerIV, blob)
				blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
				blob_signature = encryption.sign_message(innerkey, blob_encrypted)
				blob_encrypted_len = 10 + len(blob_encrypted) + 20
				blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL",
																								   blob_encrypted_len,
																								   0) + blob_encrypted + blob_signature
				# client_socket.send(b"\x00" + blob_encrypted)
				client_socket.send(blob_encrypted)

				execdict = {}
				with open("files/users/" + username.decode('latin-1') + ".py", 'r') as f:
					userblobstr = f.read( )
					execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
				for sub_dict in execdict:
					if sub_dict == b"\x07\x00\x00\x00":
						for sub_sub_dict in execdict[sub_dict]:
							if execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] == b"\x01\x00":
								# execdict[sub_dict][sub_sub_dict][b'\x03\x00\x00\x00'] = b"\x01\x00"
								execdict[sub_dict][sub_sub_dict][b'\x05\x00\x00\x00'] = b"\x00"
								# execdict[sub_dict][sub_sub_dict][b'\x06\x00\x00\x00'] = b"\x00\x00"
				with open("files/users/" + username.decode('latin-1') + ".py", 'w') as g:
					g.write("user_registry = " + str(execdict))
		elif command[0:1] == b"\x04":  # Logout
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}User {username} logged out")
		elif command[0:1] == b"\x0a":  # Request content ticket Steam beta 2003
			ticket_full = binascii.b2a_hex(command)
			command = ticket_full[0:2]
			ticket_len = ticket_full[2:6]
			tgt_ver = ticket_full[6:10]
			data1_len = ticket_full[10:14]
			data1_len = int(data1_len, 16) * 2
			userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
			username_len = ticket_full[314:318]
			username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
			log.info(f"{clientid}Content login for: {username}")
			ticket_len = int(ticket_len, 16) * 2
			postticketdata = ticket_full[2 + ticket_len + 4:]
			key = binascii.a2b_hex("10231230211281239191238542314233")
			iv = binascii.a2b_hex(postticketdata[0:32])
			encdata_len = int(postticketdata[36:40], 16) * 2
			encdata = postticketdata[40:40 + encdata_len]
			decodedmessage = binascii.b2a_hex(encryption.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
			# ------------------------------------------------------------------

			# Incompatible ContentTicket VersionNum
			# u16SizeOfPlaintextClientReadableContentTicket
			# Bad u16SizeOfAESEncryptedClientReadableContentTicket

			# u16SizeOfServerReadableContentTicket

			currtime = time.time( )

			client_ticket = b"\x69" * 0x10  # key used for MAC signature
			client_ticket += utils.unixtime_to_steamtime(currtime)  # TicketCreationTime
			client_ticket += utils.unixtime_to_steamtime(currtime + 86400)  # TicketValidUntilTime
			client_ticket += os.urandom(4)  # struct.pack("<I", 1)
			client_ticket += os.urandom(8)  # struct.pack("<II", 1, 2)
			if str(client_address[0]) in ipcalc.Network(str(globalvars.server_net)):
				client_ticket += utils.encodeIP((self.config["server_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary
			else:
				client_ticket += utils.encodeIP((self.config["public_ip"], self.config["content_server_port"])) + b"\x00\x00"  # why are there extra bytes? maybe padding to 4 byte boundary

			server_ticket = b"\x55" * 0x80

			innerIV = secrets.token_bytes(16)

			client_ticket_encrypted = encryption.aes_encrypt(key, innerIV, client_ticket)  # steam.encrypt_with_pad(client_ticket, key, innerIV)

			ticket = b"\x00\x01" + innerIV + struct.pack(">HH", len(client_ticket), len(client_ticket_encrypted)) + client_ticket_encrypted  # FOR BETA 2003
			ticket += struct.pack(">H", len(server_ticket)) + server_ticket

			# ticket_signed = ticket + hmac.digest(client_ticket[0:16], ticket, hashlib.sha1)
			ticket_signed = ticket + hmac.new(client_ticket[0:16], ticket, hashlib.sha1).digest( )

			client_socket.send(b"\x00\x01" + struct.pack(">I", len(ticket_signed)) + ticket_signed)
		elif command[0:1] == b"\x1d" or command[0:1] == b"\x1e":  # Check username - new user
			self.send_mainkey(client_socket)
			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)
			username = plainblob[b'\x01\x00\x00\x00']
			username_str = username.rstrip(b'\x00')
			# print(len(username_str))
			log.info(f"{clientid}New user: check username exists: {username_str}")
			# TODO BEN SEND SUGGESTED NAMES IF NAME EXISTS
			if (os.path.isfile("files/users/" + username_str + ".py")):
				log.warning(f"{clientid}New user: username already exists")
				client_socket.send(b"\xff")  # not working
			else:
				log.info(f"{clientid}New user: username not found")
				client_socket.send(b"\x00")
		elif command[0:1] == b"\x22":  # Check email - new user
			self.send_mainkey(client_socket)

			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)
			email = plainblob[b'\x01\x00\x00\x00']
			email_str = email.rstrip(b'\x00')
			# print(len(username_str))
			log.info(f"{clientid}New user: check email exists: " + email_str)
			email_exists = False
			for file in os.listdir("files/users/"):
				if file.endswith("py"):
					with open("files/users/" + file, 'r') as f:
						userblobstr = f.read( )
						userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
					email_addr = userblob[b'\x0b\x00\x00\x00']
					if email_addr.rstrip(b'\x00') == email_str:
						email_exists = True
						break
			if email_exists == True:
				log.warning(f"{clientid}New user: email already in use")
				client_socket.send(b"\xff")  # not working
			else:
				log.info(f"{clientid}New user: email ok to use")
				client_socket.send(b"\x00")
		elif command[0:1] == b"\x01":  # New user
			log.info(f"{clientid}New user: Create user")
			self.send_mainkey(client_socket)

			reply = client_socket.recv_withlen( )

			encr_key_len, = struct.unpack(">H", reply[0:2])
			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:144 + datalength - 10]  # modified for Steam '03 support

			# encr_key = reply[2:2 + encr_key_len]
			# key = PKCS1_OAEP.new(steam.network_key).decrypt(encr_key)
			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			# print(plaintext)
			plainblob = blobs.blob_unserialize(plaintext)
			# print(plainblob)

			username = plainblob[b'\x01\x00\x00\x00']
			username_str = username.rstrip(b'\x00')

			# invalid6 = {b'\x06\x00\x00\x00'}
			# def without_keys(d, keys) :
			#    return {x: d[x] for x in d if x not in keys}

			# plainblob_fixed = without_keys(plainblob, invalid6)

			# dict6 = {}
			# dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}

			# plainblob_fixed.update(dict6)

			newsteamid = os.urandom(4) + b"\x00\x00\x00\x00"  # generate random steamId
			plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid
			plainblob[b'\x0f\x00\x00\x00'] = {}  # adding for subscribe support

			plainblob_fixed = pprint.pformat(plainblob)

			with open("files/users/" + username_str + ".py", 'w') as userblobfile:
				userblobfile.write("user_registry = ")
				userblobfile.write(str(plainblob))

			client_socket.send(b"\x01")  # TO DO SEND \x00 FOR EMAIL IN USE
		elif command[0:1] == b"\x0e":  # Check username - password reset
			log.info(f"{clientid}Password reset: check username exists")
			self.send_mainkey(client_socket)
			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
			IV = cryptedblob[4:20]
			ciphertext = cryptedblob[20:-20]
			plaintext = encryption.aes_decrypt(key, IV, ciphertext)
			plaintext = plaintext[0:plaintext_length]
			print(plaintext)
			blobdict = blobs.blob_unserialize(plaintext)
			print(blobdict)
			usernamechk = blobdict[b'\x01\x00\x00\x00']
			username_str = usernamechk.rstrip(b'\x00')
			if os.path.isfile("files/users/" + username_str + ".py"):
				client_socket.send(b"\x00")
			else:
				client_socket.send(b"\x01")
		elif command[0:1] == b"\x0f":  # Reset password
			log.info(f"{clientid}Password reset by client")
			self.send_mainkey(client_socket)
			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				usernamechk = blobdict[b'\x01\x00\x00\x00']
				username_str = usernamechk.rstrip(b'\x00')
				with open("files/users/" + username_str + ".py", 'r') as userblobfile:
					userblobstr = userblobfile.read( )
					userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
				# print(userblob)
				questionsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x05\x00\x00\x00']
				# print(questionsalt)
				client_socket.send(questionsalt)  # USER'S QUESTION SALT
				reply2 = client_socket.recv_withlen( )

				header = reply2[0:2]
				enc_len = reply2[2:6]
				zeros = reply2[6:10]
				blob_len = reply2[10:14]
				innerIV = reply2[14:30]
				enc_blob = reply2[30:-20]
				sig = reply2[-20:]
				dec_blob = encryption.aes_decrypt(key, innerIV, enc_blob)
				padding_byte = dec_blob[-1:]
				padding_int = struct.unpack(">B", padding_byte)
				unser_blob = blobs.blob_unserialize(dec_blob[:-padding_int[0]])

				if unser_blob[b'\x01\x00\x00\x00'] == userblob[b'\x05\x00\x00\x00'][username_str][b'\x04\x00\x00\x00']:
					userblob[b'\x05\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = unser_blob[b'\x03\x00\x00\x00']
					userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00'] = unser_blob[b'\x02\x00\x00\x00']
					if (os.path.isfile("files/users/" + username_str + ".py")):
						with open("files/users/" + username_str + ".py", 'w') as userblobfile:
							userblobfile.write("user_registry = ")
							userblobfile.write(str(userblob))
						log.info(f"{clientid}Password changed for: {username_str}")
						client_socket.send(b"\x00")
					else:
						log.warning(f"{clientid}SADB file error for: {username_str}")
						client_socket.send(b"\x01")
				else:
					log.warning(f"{clientid}Password change failed for: {username_str}")
					client_socket.send(b"\x01")
			else:
				log.warning(f"{clientid}Password change message could not be decrypted")
				client_socket.send(b"\x01")

			reply = {}
			reply2 = {}
		elif command[0:1] == b"\x20":  # Check email - password reset
			log.info(f"{clientid}Password reset by email")
			self.send_mainkey(client_socket)
			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				emailchk = blobdict[b'\x01\x00\x00\x00']
				email_str = emailchk.rstrip(b'\x00')
				email_found = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read( )
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						email_addr = userblob[b'\x0b\x00\x00\x00']
						if email_addr.rstrip(b'\x00') == email_str:
							email_found = True
							break
				if email_found:
					client_socket.send(b"\x00")
				else:
					client_socket.send(b"\x01")
		elif command[0:1] == b"\x21":  # Check key - password reset
			log.info(f"{clientid}Password reset by CD key")
			self.send_mainkey(client_socket)
			reply = client_socket.recv_withlen( )

			RSAdata = reply[2:130]
			datalength = struct.unpack(">L", reply[130:134])[0]
			cryptedblob_signature = reply[134:136]
			cryptedblob_length = reply[136:140]
			cryptedblob_slack = reply[140:144]
			cryptedblob = reply[144:]

			key = encryption.get_aes_key(RSAdata, encryption.network_key)
			log.debug(f"Message verification:{repr(encryption.verify_message(key, cryptedblob))}")
			if repr(encryption.verify_message(key, cryptedblob)):
				plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
				IV = cryptedblob[4:20]
				ciphertext = cryptedblob[20:-20]
				plaintext = encryption.aes_decrypt(key, IV, ciphertext)
				plaintext = plaintext[0:plaintext_length]
				# print(plaintext)
				blobdict = blobs.blob_unserialize(plaintext)
				# print(blobdict)
				keychk = blobdict[b'\x01\x00\x00\x00']
				key_str = keychk.rstrip(b'\x00')
				key_found = False
				for file in os.listdir("files/users/"):
					if file.endswith("py"):
						with open("files/users/" + file, 'r') as f:
							userblobstr = f.read( )
							userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
						for sub in userblob[b'\x0f\x00\x00\x00']:
							for prodcdkey in userblob[b'\x0f\x00\x00\x00'][sub][b'\x01\x00\x00\x00']:
								if prodcdkey == b"\x06":
									key = userblob[b'\x0f\x00\x00\x00'][sub][b'\x02\x00\x00\x00'][b'\x02\x00\x00\x00'][:-1]
									if key == key_str:
										key_found = True
										break
				if key_found:
					client_socket.send(b"\x00")
				else:
					client_socket.send(b"\x01")
		elif command[0:1] == b"\x0b":  # Send CDR for v2 beta
			if os.path.isfile("files/cache/secondblob.bin"):
				with open("files/cache/secondblob.bin", "rb") as f:
					blob = f.read( )
			elif os.path.isfile("files/2ndcdr.py") or os.path.isfile("files/secondblob.py"):
				if os.path.isfile("files/2ndcdr.orig"):
					# shutil.copy2("files/2ndcdr.py","files/2ndcdr.orig")
					os.remove("files/2ndcdr.py")
					shutil.copy2("files/2ndcdr.orig", "files/secondblob.py")
					os.remove("files/2ndcdr.orig")
				if os.path.isfile("files/2ndcdr.py"):
					shutil.copy2("files/2ndcdr.py", "files/secondblob.py")
					os.remove("files/2ndcdr.py")
				with open("files/secondblob.py", "r") as g:
					file = g.read( )

				for (search, replace, info) in globalvars.replacestringsCDR:
					fulllength = len(search)
					newlength = len(replace)
					missinglength = fulllength - newlength
					if missinglength < 0:
						print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
					else:
						fileold = file
						file = file.replace(search, replace)
						if (search in fileold) and (replace in file):
							print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")
				# h = open("files/2ndcdr.py", "w")
				# h.write(file)
				# h.close()

				execdict = {}
				execdict_temp_01 = {}
				execdict_temp_02 = {}
				# execfile("files/2ndcdr.py", execdict)
				exec(file, execdict)

				for file in os.walk("files/custom"):
					for pyblobfile in file[2]:
						if (pyblobfile.endswith(".py") or pyblobfile.endswith(
								".bin")) and not pyblobfile == "2ndcdr.py" and not pyblobfile == "1stcdr.py" and not pyblobfile.startswith(
								"firstblob") and not pyblobfile.startswith("secondblob"):
							# if os.path.isfile("files/extrablob.py") :
							log.info(f"{clientid}Found extra blob: " + pyblobfile)
							execdict_update = {}

							if pyblobfile.endswith(".bin"):
								f = open("files/custom/" + pyblobfile, "rb")
								blob = f.read( )
								f.close( )

								if blob[0:2] == b"\x01\x43":
									blob = zlib.decompress(blob[20:])
								blob2 = blobs.blob_unserialize(blob)
								blob3 = blobs.blob_dump(blob2)
								execdict_update = b"blob = " + blob3

								for (search, replace, info) in globalvars.replacestringsCDR:
									print("Fixing CDR 1")
									fulllength = len(search)
									newlength = len(replace)
									missinglength = fulllength - newlength
									if missinglength < 0:
										print(
											f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
									else:
										execdict_update = execdict_update.replace(search, replace)
										print(
											f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

							elif pyblobfile.endswith(".py"):
								with open("files/custom/" + pyblobfile, 'r') as m:
									userblobstr_upd = m.read( )

								for (search, replace, info) in globalvars.replacestringsCDR:
									print("Fixing CDR 2")
									fulllength = len(search)
									newlength = len(replace)
									missinglength = fulllength - newlength
									if missinglength < 0:
										print(
											f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
									else:
										userblobstr_upd = userblobstr_upd.replace(search, replace)
										print(
											f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

								execdict_update = ast.literal_eval(userblobstr_upd[7:len(userblobstr_upd)])

							for k in execdict_update:
								for j in execdict[b"blob"]:
									if j == k:
										execdict[b"blob"][j].update(execdict_update[k])
									else:
										if k == b"\x01\x00\x00\x00":
											execdict_temp_01.update(execdict_update[k])
										elif k == b"\x02\x00\x00\x00":
											execdict_temp_02.update(execdict_update[k])

							for k, v in execdict_temp_01.items( ):
								execdict[b"blob"].pop(k, v)

							for k, v in execdict_temp_02.items( ):
								execdict[b"blob"].pop(k, v)

				blob = blobs.blob_serialize(execdict[b"blob"])

				if blob[0:2] == b"\x01\x43":
					blob = zlib.decompress(blob[20:])

				start_search = 0
				while True:
					found = blob.find(b"\x30\x81\x9d\x30\x0d\x06\x09\x2a", start_search)
					if found < 0:
						break

					# TINserver's Net Key
					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"

					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
					foundstring = blob[found:found + 160]
					blob = blob.replace(foundstring, encryption.BERstring)
					start_search = found + 160

				compressed_blob = zlib.compress(blob, 9)
				blob = b"\x01\x43" + struct.pack("<QQH", len(compressed_blob) + 20, len(blob), 9) + compressed_blob

				# cache_option = self.config["use_cached_blob"]
				# if cache_option == "true" :
				f = open("files/cache/secondblob.bin", "wb")
				f.write(blob)
				f.close( )

			else:
				if os.path.isfile("files/secondblob.orig"):
					os.remove("files/secondblob.bin")
					shutil.copy2("files/secondblob.orig", "files/secondblob.bin")
					os.remove("files/secondblob.orig")
				with open("files/secondblob.bin", "rb") as g:
					blob = g.read( )

				if blob[0:2] == b"\x01\x43":
					blob = zlib.decompress(blob[20:])
				blob2 = blobs.blob_unserialize(blob)
				blob3 = blobs.blob_dump(blob2)
				file = b"blob = " + blob3

				for (search, replace, info) in globalvars.replacestringsCDR:
					print("Fixing CDR 3")
					fulllength = len(search)
					newlength = len(replace)
					missinglength = fulllength - newlength
					if missinglength < 0:
						print(f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
					else:
						file = file.replace(search, replace)
						print(f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

				execdict = {}
				execdict_temp_01 = {}
				execdict_temp_02 = {}
				exec(file, execdict)

				for file in os.walk("files/custom"):
					for pyblobfile in file[2]:
						if (pyblobfile.endswith(".py") or pyblobfile.endswith(
								".bin")) and not pyblobfile == "2ndcdr.py" and not pyblobfile == "1stcdr.py" and not pyblobfile.startswith(
								"firstblob") and not pyblobfile.startswith("secondblob"):
							# if os.path.isfile("files/extrablob.py") :
							log.info(f"{clientid}Found extra blob: " + pyblobfile)
							execdict_update = {}

							if pyblobfile.endswith(".bin"):
								f = open("files/custom/" + pyblobfile, "rb")
								blob = f.read( )
								f.close( )

								if blob[0:2] == b"\x01\x43":
									blob = zlib.decompress(blob[20:])
								blob2 = blobs.blob_unserialize(blob)
								blob3 = blobs.blob_dump(blob2)
								execdict_update = "blob = " + blob3

								for (search, replace, info) in globalvars.replacestringsCDR:
									print("Fixing CDR 4")
									fulllength = len(search)
									newlength = len(replace)
									missinglength = fulllength - newlength
									if missinglength < 0:
										print(
											f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
									else:
										execdict_update = execdict_update.replace(search, replace)
										print(
											f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

							elif pyblobfile.endswith(".py"):
								with open("files/custom/" + pyblobfile, 'r') as m:
									userblobstr_upd = m.read( )

								for (search, replace, info) in globalvars.replacestringsCDR:
									print("Fixing CDR 5")
									fulllength = len(search)
									newlength = len(replace)
									missinglength = fulllength - newlength
									if missinglength < 0:
										print(
											f"WARNING: Replacement text {replace.decode('latin-1')} is too long! Not replaced!")
									else:
										userblobstr_upd = userblobstr_upd.replace(search, replace)
										print(
											f"Replaced {info} {search.decode('latin-1')} with {replace.decode('latin-1')}")

								execdict_update = ast.literal_eval(userblobstr_upd[7:len(userblobstr_upd)])

							for k in execdict_update:
								for j in execdict[b"blob"]:
									if j == k:
										execdict[b"blob"][j].update(execdict_update[k])
									else:
										if k == b"\x01\x00\x00\x00":
											execdict_temp_01.update(execdict_update[k])
										elif k == b"\x02\x00\x00\x00":
											execdict_temp_02.update(execdict_update[k])

							for k, v in execdict_temp_01.items( ):
								execdict[b"blob"].pop(k, v)

							for k, v in execdict_temp_02.items( ):
								execdict[b"blob"].pop(k, v)

				blob = blobs.blob_serialize(execdict[b"blob"])

				# h = open("files/secondblob.bin", "wb")
				# h.write(blob)
				# h.close()

				# g = open("files/secondblob.bin", "rb")
				# blob = g.read()
				# g.close()

				if blob[0:2] == b"\x01\x43":
					blob = zlib.decompress(blob[20:])

				start_search = 0
				while True:
					found = blob.find(b"\x30\x81\x9d\x30\x0d\x06\x09\x2a", start_search)
					if found < 0:
						break

					# TINserver's Net Key
					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"

					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
					# BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
					foundstring = blob[found:found + 160]
					blob = blob.replace(foundstring, encryption.BERstring)
					start_search = found + 160

				compressed_blob = zlib.compress(blob, 9)
				blob = b"\x01\x43" + struct.pack("<QQH", len(compressed_blob) + 20, len(blob), 9) + compressed_blob

				# cache_option = self.config["use_cached_blob"]
				# if cache_option == "true" :
				f = open("files/cache/secondblob.bin", "wb")
				f.write(blob)
				f.close( )

			checksum = SHA.new(blob).digest( )

			if checksum == command[1:]:
				log.info(f"{clientid}Client has matching checksum for secondblob")
				log.debug(f"{clientid}We validate it: {binascii.b2a_hex(command)}")

				client_socket.send(b"\x00\x00\x00\x00")

			else:
				log.info(f"{clientid}Client didn't match our checksum for secondblob")
				log.debug(f"{clientid}Sending new blob: {binascii.b2a_hex(command)}")

				client_socket.send_withlen(blob, True)  # false for not showing in log
		else:
			log.debug(f"{clientid}Unknown command: {binascii.b2a_hex(command[0:1])}")  # 23 ?
			client_socket.send(b"\x01")